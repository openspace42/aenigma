#!/bin/bash

set -e
set -u

r=$(tput setaf 1)
g=$(tput setaf 2)
l=$(tput setaf 4)
m=$(tput setaf 5)
x=$(tput sgr0)
b=$(tput bold)

echo "${g}${b}aenigma.xyz ejabberd installer by openspace [https://github.com/openspace42/aenigma]${x}"
echo

filename=$(basename "$0")
currvers="$(echo "${filename//installer-v/}")"

echo "${b}aenigma v$currvers${x}"
echo

sourcedir=/root/aenigma # Don't change! | No trailing slash!
basedir=/root/openspace42 # Don't change! | No trailing slash!
installdir=$basedir/aenigma # Don't change! | No trailing slash!
configdir=$installdir/config # Don't change! | No trailing slash!
toolsdir=$installdir/tools # Don't change! | No trailing slash!
backupsdir=$installdir/backups # Don't change! | No trailing slash!
localbackupsdir=$backupsdir/local # Don't change! | No trailing slash!
s3backupsdir=$backupsdir/s3 # Don't change! | No trailing slash!
restoresdir=$installdir/restores # Don't change! | No trailing slash!
tlsdir=/etc/ssl/aenigma # Don't change! | No trailing slash!
tmpdir=/tmp/aenigma # Don't change! | No trailing slash!

mkdir -p $basedir
mkdir -p $tlsdir
mkdir -p $tmpdir



if [ -d $configdir ]
then
	previnstall=y
	echo "${g}${b}Found a previous install of aenigma.${x}"
	echo
	read -rp "${b}Skip the introduction on XMPP basics? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, continuing...${x}"
		echo
		skipintro=y
	else
		echo
		skipintro=n
	fi
else
	mkdir -p $configdir
	previnstall=n
	skipintro=n
fi



if [ -f $configdir/installedvers ]
then
	prevvers="$(cat $configdir/installedvers)"
	if (( $(echo "$currvers < $prevvers" | bc -l) ))
	then
        	echo "${r}${b}You have previously installed a newer version of aenigma.${x}"
		echo
		echo "${b}You likely recently opted out of beta versions. If so, please re-enable beta versions until the next version's stable release.${x}"
		echo
		echo "${b}Exiting...${x}"
		echo
		exit
	else
		echo "$currvers" > "$configdir"/installedvers
	fi
else
	prevvers=null
	touch $configdir/installedvers
	echo "$currvers" > $configdir/installedvers
fi



### Alert for previous incomplete install [only from v0.46 onward, since the complete installation signaling was implemented in v0.45]

incompleteinstall=n

if [ ! $prevvers = "null" ]
then
	if (( $(echo "$prevvers > 0.45" | bc -l) ))
	then
		if [ ! -f $configdir/installcomplete ]
		then
			incompleteinstall=y
		else
			lastcompleteinstallvers="$(cat $configdir/installcomplete)"
			if [ "$lastcompleteinstallvers" != "$prevvers" ]
			then
				incompleteinstall=y
			fi
		fi
	fi
fi

if [ $incompleteinstall = "y" ]
then
	clear
	echo "${r}${b}It appears you have a previous incomplete installation of aenigma.${x}"
	echo
	echo "${b}Either you intentionally aborted the install or the script got somehow terminated before it finished.${x}"
	echo
	echo "${b}In the latter case, it is possible something unforseen might go wrong during this install. If so, simply file an issue report at:${x}"
	echo
	echo "${b} | https://github.com/openspace42/aenigma/issues | ${x}"
	echo
	echo "${b}Thank you in advance!${x}"
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear
fi



### Alert in case of reinstall

if [ ! $prevvers = "null" ]
then

	echo "${b}You're now re-running the aenigma installer.${x}"
	echo
	echo "${g}${b}This is perfectly fine as aenigma is meant to be re-installed as many times as you'd like [also to update your current installation].${x}"
	echo
	echo "${r}${b}Keep in mind though that all customizations external to aenigma you might have made will be permanently deleted.${x}"
	echo
	echo "${b}This is because the installation script goes through every configuration and sets the default values, with no regard to any anomaly it finds.${x}"
	echo
	echo "${r}${b}If you want to save any customizations you have made, exit this script and do so now.${x}"
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "${b}It's highly recommended to run one last, fully automated backup before you proceed with the aenigma installer re-run.${x}"
	echo
	read -rp "${b}Do you want to run the backup now [without exiting this script] (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, proceeding with backup...${x}"
		bash $sourcedir/tools/aenigma-backup
		echo
		echo "${b}Backup complete. Continuing installtion...${x}"
		echo
	else
		echo "${b}Ok, skipping backup...${x}"
		echo
	fi

fi



if [ $skipintro = "n" ]
then

	echo "0] First of all, a little introduction on how XMPP actually works"
	echo
	echo "XMPP works a little bit like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains. In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	echo
	echo "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at xmpp.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at xmpp.amsterdamhacklab.xyz."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "1] Now, if the domain for which you're setting up your new aenigma server is a domain connected to a bigger project, for which XMPP is just another way of getting in touch with you, definitely set things up like this by using the first option."
	echo
	echo "This will give you working @domain.tld xmpp account addresses, but the aenigma server will reside at subdomain.domain.tld, as in the following example."
	echo
	echo "Main domain:          amsterdamhacklab.xyz."
	echo "Website:              amsterdamhacklab.xyz / www.amsterdamhacklab.xyz [hosted by another server]."
	echo "Your XMPP address:    mark@amsterdamhacklab.xyz."
	echo "XMPP server:          xmpp.amsterdamhacklab.xyz"
	echo
	echo "PROs:                 a] clean addresses [no mark@xmpp.amsterdamhacklab.xyz stuff]"
	echo "                      b] more logical setup."
	echo "CONs:                 a] requires TLS [SSL] certificate for the top level domain [amsterdamhacklab.xyz]"
	echo "                         to be copied over to your new aenigma server [not hard at all, can be automated, see below]"
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "2] If instead your domain [i.e. aenigmapod42.im] is only intended to be used for your shiny new aenigma server, and you don't need other, different servers [a webserver for instance] managing different aspects of your project, you can do as so:"
	echo
	echo "Set your aenigma server to be located directly at your top level domain, therefore responding directly to amsterdamhacklab.xyz."
	echo
	echo "Your server hostname:  aenigmapod42.im"
	echo "Your addresses:        mark@aenigmapod42.im."
	echo
	echo "PROs:                  a] clean addresses"
	echo "                       b] no separate TLS certificate needed."
	echo "CONs:                  a] your domain must be logically dedicated to your aenigma server"
	echo "                          and not to a wider project."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "3] In a third, although NOT suggested case, if you have a domain tied to a wider project [i.e. amsterdamhacklab.xyz] but you don't mind having longer and more complex XMPP account addresses [like mark@xmpp.amsterdamhacklab.xyz], you can choose the third option."
	echo
	echo "Your server hostname:  subdomain.domain.tld"
	echo "Your addresses:        mark@subdomain.domain.tld."
	echo
	echo "PROs:                  a] domain can be logically connected to other stuff and different servers"
	echo "                          with no separate TLS certificate needed."
	echo "CONs:                  a] longer and more complex addresses"
	echo "                       b] not logically 'clean'."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "Now that you know how XMPP works, make your choice and let's get your brand new aenigma server up and running!"
	echo
	echo "----------------"
	echo

fi



if [ -f $configdir/configoption ]
then
	prevconfigoption="$(cat $configdir/configoption)"
	case "$prevconfigoption" in
	    1|2|3)
		validprevconfigoption=y
		;;
	    *)
		validprevconfigoption=n
		;;
	esac
else
	touch $configdir/configoption
	validprevconfigoption=n
fi

if [ $validprevconfigoption = "y" ]
then
	echo "${g}${b}You previously chose configuration option | $prevconfigoption | ${x}"
	echo
	read -rp "${b}Keep this option for this installation as well? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		configoption=$prevconfigoption
	else
		echo
		configoption=notyetset
	fi
else
	configoption=notyetset
fi

if [ $configoption = "notyetset" ]
then
	choice="${b}Please select your desired configuration option: ${x}"
	echo "$choice"
	options=("configuration 1" "configuration 2" "configuration 3" "exit")
	select opt in "${options[@]}"
	do
	    echo
	    case $opt in
		"configuration 1")
		    echo "1" > $configdir/configoption
		    configoption=1
		    break
		    ;;
		"configuration 2")
		    echo "2" > $configdir/configoption
		    configoption=2
		    break
		    ;;
		"configuration 3")
		    echo "3" > $configdir/configoption
		    configoption=3
		    break
		    ;;
		"exit")
		    echo "${b}Exiting...${x}"
		    echo
		    exit
		    ;;
		*)  echo "${r}${b}Invalid option. Retry...${x}"
		    echo
		    ;;
	    esac
	done
fi



if [ -f $configdir/domain ]
then
	prevdomain="$(cat $configdir/domain)"
	changedomainwarning=y
else
	prevdomain="nx"
	changedomainwarning=n
fi

if [ ! $configoption = "3" ]
then

	echo "${b}Ok, you've chosen option $configoption.${x}"
	echo
	if [ ! $prevdomain = "nx" ]
	then
		echo "${g}${b}The domain used for your previous aenigma installation is:${x}"
		echo
		echo " | $prevdomain |"
		echo
		read -rp "${b}Keep this domain for this installation as well? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			echo "${b}Ok, using previous domain: | $prevdomain | ${x}"
			echo
			domain=$prevdomain
			changedomain=n
		else
			echo
			echo "${b}Ok, changing domain...${x}"
			echo
			changedomain=y
		fi
	else
		changedomain=y
	fi

	if [ $changedomain = "y" ]
	then

		if [ $changedomainwarning = "y" ]
		then
			echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
			echo
			echo "${r}${b}WARNING:${x}"
			echo
			echo "${r}${b}Changing domains will not preserve any user accounts or data. It will revert this server to a fresh install.${x}"
			echo
			echo "${b}In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run the install and select the old domain, but this hasn't been thoroughly tested yet."
			echo
			echo "${b}If you abort the domain change operation now, nothing will be deleted.${x}"
			echo
			echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
			echo
			read -rp "${b}Are you absolutely sure you want to change the XMPP domain now? (y/N): ${x}" -n 1
			echo
			if [[ $REPLY =~ ^[Yy]$ ]]
			then
				confirmchangedomain=y
			else
				confirmchangedomain=n
			fi
			clear
		else
			confirmchangedomain=y
		fi

		if [ $confirmchangedomain = "y" ]
		then
			defined=n
			until [ $defined = "y" ]
			do
				newdomain=""
				until [ ! $newdomain = "" ]
				do
					read -rp "${b}Now set your top level domain, which will also be the part after the @ in your XMPP account addresses: ${x}" newdomain
					echo
				done
				valid=n
				until [ $valid = "y" ]
				do
					read -n 1 -rp "${b}Is | $newdomain | correct? (Y/n/e[xit]) ${x}" answer;
					case $answer in
					"")
						echo
						valid=y
						defined=y
						;;
					y)
						echo -e "\\n"
						valid=y
						defined=y
						;;
					n)
						echo -e "\\n"
						echo "${b}Ok, then please try again...${x}"
						echo
						valid=y
						defined=n
						;;
					e)
						echo -e "\\n"
		        			echo "${b}Exiting...${x}"
		        			echo
		        			exit
		        			;;
					*)
						echo -e "\\n"
						echo "${r}${b}Invalid option. Retry...${x}"
		        			echo
						valid=n
						defined=n
			        		;;
					esac
				done
			done
			echo "$newdomain" > "$configdir"/domain
			echo "${b}New domain set to | $newdomain | ${x}"
			echo
			domain="$(cat $configdir/domain)"
		else
			domain=$prevdomain
			echo "${b}Aborting domain change. Keeping old domain | $domain | ${x}"
			echo
		fi

	fi

else

	echo "${b}Ok, you've chosen option 3.${x}"
	echo
	echo "${b}Your domain [the part after the @ in your XMPP account addresses] will match your server hostname.${x}"
	echo

fi



currhostname="$(cat /etc/hostname)"

if [ ! $configoption = "2" ]
then

	if [ $configoption = "1" ]
	then
		echo "${b}Your hostname must be a third level domain [subdomain] of either $domain or another domain.${x}"
		echo
	elif [ $configoption = "3" ]
	then
		echo "${b}Your hostname must be a third level domain [subdomain] of your main domain.${x}"
		echo
	fi

	echo "${g}${b}Your current hostname is:${x}"
	echo
	echo " | $currhostname |"
	echo

	if [ $configoption = "3" ]
	then
		echo "${b}Make sure it is a subdomain of your main domain, and is it what you want it to be.${x}"
		echo
	fi

	read -rp "${b}Keep this hostname? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, leaving hostname set to | $currhostname | ${x}"
		echo
		changehostname=n
		hostname=$currhostname
	else
		echo
		echo "${b}Ok, changing hostname...${x}"
		echo
		changehostname=y
	fi

	if [ $changehostname = "y" ]
	then
		defined=n
		until [ $defined = "y" ]
		do
			newhostname=""
			until [ ! $newhostname = "" ]
			do
				if [ $configoption = "1" ]
				then
					read -rp "${b}Now set your hostname, which must be a third level domain [subdomain] of either $domain or another domain: ${x}" newhostname
					echo
				elif [ $configoption = "3" ]
				then
					echo "${b}Keep in mind that your hostname will also become your domain [the part after the @ in your XMPP account addresses].${x}"
					echo
					read -rp "${b}Now set your hostname, which must be a third level domain [subdomain] of your main domain: ${x}" newhostname
					echo
				fi
			done
			valid=n
			until [ $valid = "y" ]
			do
				read -n 1 -rp "${b}Is | $newhostname | correct? (Y/n/e[xit]) ${x}" answer;
				case $answer in
				"")
					echo
					valid=y
					defined=y
					;;
				y)
					echo -e "\\n"
					valid=y
					defined=y
					;;
				n)
					echo -e "\\n"
					echo "${b}Ok, then please try again...${x}"
					echo
					valid=y
					defined=n
					;;
				e)
					echo -e "\\n"
		        		echo "${b}Exiting...${x}"
		        		echo
		        		exit
		        		;;
				*)
					echo -e "\\n"
					echo "${r}${b}Invalid option. Retry...${x}"
		        		echo
					valid=n
				defined=n
			        ;;
				esac
			done
		done
		echo "$newhostname" > /etc/hostname
		echo "${b}New hostname set to | $newhostname | ${x}"
		echo
		hostname="$(cat /etc/hostname)"
	fi

	if [ $configoption = "3" ]
	then
		domain=$hostname
	fi

else

	echo "${b}Your hostname must be identical to your domain: $domain.${x}"
	echo
	echo "${b}Your current hostname is:${x}"
	echo
	echo " | $currhostname |"
	echo
	if [ "$currhostname" = "$domain" ]
	then
		echo "${g}${b}Your hostname matches your domain, all good!${x}"
		echo
	else
		echo "${r}${b}Your hostname does NOT match the domain you've specified.${x}"
		echo
		echo "${b}Having chosen option 2, they must be identical.${x}"
		echo
		read -rp "${b}Do you want to set your hostname to match your domain? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			echo "${b}Ok, setting hostname to match domain.${x}"
			echo
			echo "$domain" > /etc/hostname
			echo "${b}New hostname set to | $domain | ${x}"
			echo
		else
			echo
			echo "${b}Not changing hostname. Exiting...${x}"
			echo
			exit
		fi
	fi

	hostname="$(cat /etc/hostname)"

fi
clear



echo "----------------"
echo
echo "${b}To make sure everything is correct:${x}"
echo
echo "1] Your XMPP domain [the part after the @ in your XMPP account addresses] will be:"
echo
echo "${b} | $domain | ${x}"
echo
echo "2] And therefore an XMPP account address will look as follows:"
echo
echo "${b} | mark@$domain | ${x}"
echo
echo "3] Your hostname, the location on the internet of this server, will be:"
echo
echo "${b} | $hostname | ${x}"
echo
echo "4] And therefore your aenigma admin panel will be located at:"
echo
echo "${b} | https://$hostname | ${x}"
echo
echo "----------------"
echo

read -rp "${b}Does everything look all right? (Y/n): ${x}" -n 1
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]
then
	echo "${b}Ok, continuing.${x}"
	echo
	touch $configdir/domain
	echo "$domain" > $configdir/domain
else
	echo
	echo "${b}Ok, no worries. You can re-run this script right now and make the correct choices. Exiting...${x}"
	echo
	exit
fi
clear



echo "${b}Aenigma sends you email notifications for any runtime errors or failures.${x}"
echo

if [ -f $configdir/adminmail ]
then
	prevadminmail="$(cat $configdir/adminmail)"

	### Perform any future email address validation here and return validprevadminmail=[y/n].
	### Now defaulting to y.

	validprevadminmail=y
else
	touch $configdir/adminmail
	validprevadminmail=n
fi

if [ $validprevadminmail = "y" ]
then
	echo "${g}${b}You previously set your admin email address to be: | $prevadminmail | ${x}"
	echo
	read -rp "${b}Is this still correct? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, keeping | $prevadminmail | as your admin email address.${x}"
		echo
		adminmail=$prevadminmail
	else
		echo
		adminmail=notyetset
	fi
else
	adminmail=notyetset
fi

if [ $adminmail = "notyetset" ]
then
	defined=n
	until [ $defined = "y" ]
	do
		newadminmail=""
		until [ ! $newadminmail = "" ]
		do
			read -rp "${b}Now set your admin email address: ${x}" newadminmail
			echo
		done
		valid=n
		until [ $valid = "y" ]
		do
			read -n 1 -rp "${b}Is | $newadminmail | correct? (Y/n/e[xit]) ${x}" answer;
			case $answer in
			"")
				echo
				valid=y
				defined=y
				;;
			y)
				echo -e "\\n"
				valid=y
				defined=y
				;;
			n)
				echo -e "\\n"
				echo "${b}Ok, then please try again...${x}"
				echo
				valid=y
				defined=n
				;;
			e)
				echo -e "\\n"
				echo "${b}Exiting...${x}"
				echo
				exit
				;;
			*)
				echo -e "\\n"
				echo "${r}${b}Invalid option. Retry...${x}"
				echo
				valid=n
				defined=n
				;;
			esac
		done
	done
	echo "$newadminmail" > "$configdir"/adminmail
	echo "${b}New admin email address set to | $newadminmail | ${x}"
	echo
	adminmail="$(cat $configdir/adminmail)"
fi
clear



thisipv4="$(dig +short myip.opendns.com @resolver1.opendns.com)"
echo "${b}Now testing IPv6 connectivity...${x}"
echo
ipv6pingaddr="2001:4860:4860::8888"
if ping6 -q -c 1 -W 1 $ipv6pingaddr >/dev/null
then
	echo "${g}${b}IPv6 connectivity good.${x}"
	echo
	ipv6avail=y
else
	counter=4
	pingacquired=y
	echo
	until ping6 -c1 $ipv6pingaddr &>/dev/null
	do
	echo "${b}Waiting $counter more seconds for IPv6 connectivity...${x}"
	echo
	if [ $counter = 0 ]
	then
		pingacquired=n
		break
	fi
	counter=$((counter - 1))
	sleep 1
	done
	if [ $pingacquired = "y" ]
	then
		echo "${g}${b}IPv6 connectivity acquired.${x}"
		echo
		ipv6avail=y
	else
		echo "${r}${b}IPv6 connectivity not found.${x}"
		echo
		ipv6avail=n
	fi
fi
if [ $ipv6avail = "y" ]
then
	thisipv6="$(dig +short -6 myip.opendns.com aaaa @resolver1.ipv6-sandbox.opendns.com)"
	echo "${b}Your IPv6 global [public] address appears to be: | $thisipv6 | ${x}"
	echo
fi
echo "${b}Finished testing IPv6 connectivity.${x}"
echo
clear



addTLSmode="notset"

if [ $configoption = 1 ]
then

	echo "${b}Having chosen config option 1, now it's time to set up the TLS [SSL] certificate that is valid for $domain on this machine.${x}"
	echo

	if [ -f $configdir/addTLSmode ]
	then
		prevaddTLSmode="$(cat $configdir/addTLSmode)"
		case "$prevaddTLSmode" in
		    "elsewhere"|"here")
			validprevaddTLSmode=y
			;;
		    *)
			validprevaddTLSmode=n
			;;
		esac
	else
		touch $configdir/addTLSmode
		validprevaddTLSmode=n
	fi

	if [ $validprevaddTLSmode = "y" ]
	then
		echo "${g}${b}You previously specified that the A/AAAA DNS records for $domain point [or are supposed to point] | $prevaddTLSmode | ${x}"
		echo
		read -rp "${b}Is this still true? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			addTLSmode=$prevaddTLSmode
		else
			echo
			addTLSmode=notyetset
		fi
	else
		addTLSmode=notyetset
	fi

	if [ $addTLSmode = "notyetset" ]
	then

		echo "The certificate file required for aenigma must be an all-in-one private key + certificate + chain file."
		echo
		echo "This means the file must include, in this order, the following:"
		echo
		echo "1] Private key; 2] Leaf [server] cert; 3] Certification Chain [Intermediate cert(s) + Root cert]"
		echo
		read -rp "${b}[press enter to continue reading...]${x}"
		clear

		echo "This certificate, if it already exists, resides on the server responding to $domain"
		echo
		echo "This is usually a web server, but check your domain/hosting infrastructure to see what server it is."
		echo
		echo "This is the IP to which your bare domain $domain is pointing to:"
		echo
		dig +noall +answer "$domain"
		echo
		echo "[If you see no output, then it might be misconfigured or not configured at all.]"
		echo
		read -rp "${b}[press enter to continue reading...]${x}"
		clear

		read -rp "${b}That said, is there ANOTHER [running] server that responds to $domain? (Y/n): ${x}" -n 1
        	echo
        	if [[ ! $REPLY =~ ^[Nn]$ ]]
        	then
			read -rp "${b}Ok, does this server have a configured TLS [SSL] certificate up and running on it? (Y/n): ${x}" -n 1
	        	echo
	        	if [[ ! $REPLY =~ ^[Nn]$ ]]
	        	then
				read -rp "${b}Ok, is this a Linux server? (Y/n): ${x}" -n 1
                        	echo
                        	if [[ ! $REPLY =~ ^[Nn]$ ]]
                        	then
					read -rp "${b}Ok, is this a Letsencrypt certificate? [if unsure, answer no] (Y/n): ${x}" -n 1
	                		echo
	                		if [[ ! $REPLY =~ ^[Nn]$ ]]
	                		then
						echo "${b}Very good, therefore access that server as root [or using sudo], and download this script in the root user's home directory:${x}"
						echo
						echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
						echo
						echo "${b}Now configure it to push its LE TLS cert to this server by following the instructions.${x}"
						echo
					else
						echo
						echo "${b}Ok, no problem, you can adapt this script:${x}"
						echo
						echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
                                        	echo
						echo "${b}To have it fetch and concatenate your existing private key, TLS cert, and certification chain on the other server and push the resulting all-in-one file here periodically.${x}"
						echo
						echo "${b}Follow the instructions and adapt the paths to the existing TLS certs and private key.${x}"
						echo
					fi
				else
					echo "${b}Ok, no problem, find your TLS certificate and related files on the other server and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!].${x}"
					echo
				fi
			else
				read -rp "${b}Ok, no problem. Is this server a linux server? (Y/n): ${x}" -n 1
                        	echo
                        	if [[ ! $REPLY =~ ^[Nn]$ ]]
                        	then
					echo "${b}Very good. You can therefore install letsencrypt on the other server, generate a cert for $domain, and copy it over here with this script:${x}"
					echo
					echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
					echo
				else
					echo "${b}Ok, no problem, get a TLS certificate, install it and its related files on the other server, and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!].${x}"
					echo
				fi
			fi

			addTLSmode="elsewhere"
			echo "elsewhere" > $configdir/addTLSmode

		else

			echo
			echo "${b}Ok, so we'll point $domain to this server and provision a TLS certificate for it on this very server.${x}"
			echo
			echo "If you ever add a new server to respond to $domain [a webserver for instance], simply make sure you periodically send the TLS certificate you'll generate on the new server back here, either by using this script on the new server:"
			echo
			echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
			echo
			echo "[or an adaptation of it] or by doing some other manual scripting that periodically fetches the TLS cert and all of its related files on the other server, concatenates your private key, TLS cert, and certification chain on the other server, and sends the resulting all-in-one file over to this server, [and does so again every time you renew the cert!]."
			echo
			echo "For now, no need to worry about that."
			echo
			read -rp "${b}[press enter to continue reading...]${x}"
			clear

			echo "${b}Let's point $domain and www.$domain to this server for the time being.${x}"
			echo
			echo "This is required for the TLS certificate we'll be generating shortly on this server."
			echo
			echo "The DNS checks we'll be running shortly will guide you through these settings as well."
			echo

			addTLSmode="here"
			echo "here" > $configdir/addTLSmode

		fi

	fi

	if [ $addTLSmode = "elsewhere" ]
	then

		if [ -f $configdir/domtlscertloc ]
		then
			prevdomtlscertloc="$(cat $configdir/domtlscertloc)"
			if [[ -f "$prevdomtlscertloc" && -s "$prevdomtlscertloc" ]]
			then
				validprevdomtlscertloc=y
			else
				validprevdomtlscertloc=n
			fi
		else
			touch $configdir/domtlscertloc
			validprevdomtlscertloc=n
		fi

		if [ $validprevdomtlscertloc = "y" ]
		then
			echo "${g}${b}You previously specified the all-in-one TLS certificate file for $domain to be | $prevdomtlscertloc | ${x}"
			echo
			read -rp "${b}Is this still correct? (Y/n): ${x}" -n 1
			echo
			if [[ ! $REPLY =~ ^[Nn]$ ]]
			then
				domtlscertloc=$prevdomtlscertloc
			else
				echo
				domtlscertloc=notyetset
			fi
		else
			domtlscertloc=notyetset
		fi

		if [ $domtlscertloc = "notyetset" ]
		then

			defined=n
			until [ $defined = "y" ]
			do
				exists=n
				until [ $exists = "y" ]
				do
					newdomtlscertloc=""
					until [ ! $newdomtlscertloc = "" ]
					do
						read -rp "${b}Now, in whatever way you've installed or copied to this server the all-in-one TLS cert file for $domain, specify its absolute path [i.e. /home/username/domain.pem] on this server now: ${x}" newdomtlscertloc
						echo
					done
					if [ -f "$newdomtlscertloc" ]
					then
						exists=y
					else
						echo "${r}${b}The specified file does not exists. Please retry...${x}"
						echo
						exists=n
					fi
				done
				valid=n
				until [ $valid = "y" ]
				do
					read -n 1 -rp "${b}Is | $newdomtlscertloc | correct? (Y/n/e[xit]) ${x}" answer;
					case $answer in
					"")
						echo
						valid=y
						defined=y
						;;
					y)
						echo -e "\\n"
						valid=y
						defined=y
						;;
					n)
						echo -e "\\n"
						echo "${b}Ok, then please try again...${x}"
						echo
						valid=y
						defined=n
						;;
					e)
						echo -e "\\n"
			        		echo "${b}Exiting...${x}"
			        		echo
			        		exit
			        		;;
					*)
						echo -e "\\n"
						echo "${r}${b}Invalid option. Retry...${x}"
			        		echo
						valid=n
					defined=n
				        ;;
					esac
				done
			done
			echo "$newdomtlscertloc" > "$configdir"/domtlscertloc
			echo "${b}New location for all-in-one TLS cert file for $domain set to | $newdomtlscertloc | ${x}"
			echo
			domtlscertloc="$(cat $configdir/domtlscertloc)"
		fi

	fi

fi
sleep 1
clear



echo "${b}Aenigma makes daily backups of this server's ejabberd database and files.${x}"
echo

if [ -f $configdir/backuptype ]
then
	prevbackuptype="$(cat $configdir/backuptype)"
	case "$prevbackuptype" in
	    local|s3)
		validprevbackuptype=y
		;;
	    *)
		validprevbackuptype=n
		;;
	esac
else
	touch $configdir/backuptype
	validprevbackuptype=n
fi

if [ $validprevbackuptype = "y" ]
then
	echo "${g}${b}You previously chose backup type | $prevbackuptype | ${x}"
	echo
	read -rp "${b}Keep this option for this installation as well? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, keeping | $prevbackuptype | as your backup type${x}"
		echo
		backuptype=$prevbackuptype
	else
		echo
		backuptype=notyetset
	fi
else
	backuptype=notyetset
fi

restoreintent=n

if [ $backuptype = "notyetset" ]
then
	echo "${b}Aenigma can perform backups to an S3 file storage server.${x}"
	echo
	echo "${b}You must choose to set up S3 now if you're restoring a previous aenigma installation.${x}"
	echo
	read -rp "${b}Do you want to set up S3 now? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, using S3 as backup type.${x}"
		echo
		read -rp "${b}Do you have an S3 file storage server already set up? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then
			echo "${b}Ok, so let's set up your S3 file storage server settings now.${x}"
			echo
			backuptype=s3
			echo "s3" > $configdir/backuptype
			echo  "${r}${b}If you're setting up this machine to restore a previous aenigma installation from another machine, you must specify so now.${x}"
			echo
			echo "${b}Selecting yes at the next prompt will block ALL backups to S3 to avoid overwriting previous valid backups on S3 and give you a chance to restore them on this machine.${x}"
			echo
			echo "${r}${b}If you choose yes, make sure NOT to use this instance as it is [as it will NOT be backed up on S3] but rather remember to perform the restore right after you're finished running this install script.${x}"
			echo
			read -rp "${b}Are you setting up this machine to restore a previous aenigma installation from another machine? (Y/n): ${x}" -n 1
			echo
			if [[ ! $REPLY =~ ^[Nn]$ ]]
			then
				echo "${r}${b}Ok, blocking ALL backups to S3 until a restore is performed. Do so right after you're finished running this install script.${x}"
				echo
				restoreintent=y
				touch $configdir/blocks3backups
			else
				echo "${b}NOT selected restore mode, will allow S3 backups..."
				echo
			fi
		else
			echo "${b}No problem, follow this guide [link will be published here when ready] to configure your S3 file storage server.${x}"
			echo
			echo "${b}Keeping backups local for now [simply re-run this installation when you're ready to upgrade your backups to S3 enabled].${x}"
			echo
			backuptype=local
			echo "local" > $configdir/backuptype
		fi
	else
		echo
		echo "${b}Ok, keeping backups local. Remember to periodically copy your backups from $backupsdir over to another machine!${x}"
		echo
		backuptype=local
		echo "local" > $configdir/backuptype
		sleep 3
	fi
fi
clear



if [ $backuptype = "s3" ]
then

	s3accepted=n

	until [ $s3accepted = "y" ]
	do

		mkdir -p $configdir/s3/

		declare -A s3array=(
			[awsaki]="AWS Access Key ID"
			[awssak]="AWS Secret Access Key"
			[s3endpoint]="S3 Endpoint URL"
			[s3bucketname]="S3 Bucket Name"
		)

		for i in "${!s3array[@]}"
		do
			if [ -f "$configdir"/s3/"$i" ]
			then
				prevs3var="$(cat "$configdir"/s3/"$i")"
				echo "${g}${b}You previously set your ${s3array[$i]} to be: | $prevs3var | ${x}"
				echo
				read -rp "${b}is this still correct? (Y/n): ${x}" -n 1
				echo
				if [[ ! $REPLY =~ ^[Nn]$ ]]
				then
					echo "${b}Ok, keeping | $prevs3var | as your ${s3array[$i]}${x}"
					echo
					news3var=$prevs3var
				else
					echo
					news3var=notyetset
				fi
			else
				news3var=notyetset
			fi

			if [ $news3var = "notyetset" ]
			then
				defined=n
				until [ $defined = "y" ]
				do
					news3var=""
					until [ ! $news3var = "" ]
					do
						read -rp "${b}Now set your ${s3array[$i]}${x}: " news3var
						echo
					done
					valid=n
					until [ $valid = "y" ]
					do
						read -n 1 -rp "${b}Is | $news3var | correct? (Y/n/e[xit]) ${x}" answer;
						case $answer in
						"")
							echo
							valid=y
							defined=y
							;;
						y)
							echo -e "\\n"
							valid=y
							defined=y
							;;
						n)
							echo -e "\\n"
							echo "${b}Ok, then please try again...${x}"
							echo
							valid=y
							defined=n
							;;
						e)
							echo -e "\\n"
							echo "${b}Exiting...${x}"
							echo
							exit
							;;
						*)
							echo -e "\\n"
							echo "${r}${b}Invalid option. Retry...${x}"
							echo
							valid=n
							defined=n
							;;
						esac
					done
				done
				echo "${b}${s3array[$i]} set to | $news3var | ${x}"
				echo
				echo "$news3var" > "$configdir"/s3/"$i"
			fi
		done

		awsaki="$(cat $configdir/s3/awsaki)"
		awssak="$(cat $configdir/s3/awssak)"
		s3endpoint="$(cat $configdir/s3/s3endpoint)"
		s3bucketname="$(cat $configdir/s3/s3bucketname)"

		echo "----------------"
		echo
		echo "${b}To make sure everything is correct:${x}"
		echo
		echo "1] Your ${b}AWS Access Key ID${x} will be:"
		echo
		echo "${b} | $awsaki | ${x}"
		echo
		echo "2] Your ${b}AWS Secret Access Key${x} will be:"
		echo
		echo "${b} | $awssak | ${x}"
		echo
		echo "3] Your ${b}S3 Endpoint URL${x} will be:"
		echo
		echo "${b} | $s3endpoint | ${x}"
		echo
		echo "4] Your ${b}S3 Bucket Name${x} will be:"
		echo
		echo "${b} | $s3bucketname | ${x}"
		echo
		echo "----------------"
		echo

		read -rp "${b}Does everything look all right? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then

			echo "${b}Ok, proceeding to check S3 connection details${x}."
			echo

			### Check S3 connection

			s3cmd --configure --access_key="$awsaki" --secret_key="$awssak" --host="$s3endpoint" -s --no-encrypt --dump-config 2>&1 | tee /root/.s3cfg &> /dev/null
			set +e
			s3cmd info s3://"$s3bucketname" >/dev/null 2>&1

			if [[ $? -eq 0 ]]; then
				echo "${g}${b}S3 connection details appear to be valid.${x}"
				echo
				s3accepted=y
				sleep 1
			else
				echo "${r}${b}S3 connection details do NOT appear to be valid.${x}"
				echo
				read -rp "${b}Would you like to try setting it up again? (Y/n): ${x}" -n 1
			    	echo
			    	if [[ ! $REPLY =~ ^[Nn]$ ]]
			    	then
					s3accepted=n
					echo "${b}Ok, repeating S3 setup...${x}"
					echo
				else
					s3accepted=y
					echo
					echo "${b}Ok, skipping S3 setup and REMOVING s3 setting from aenigma...${x}"
					echo
					backuptype=local
					echo "local" > $configdir/backuptype
					read -rp "${b}[press enter to continue reading...]${x}"
					clear
				fi
			fi
			set -e

		else
			s3accepted=n
			echo
			echo "${b}Ok, repeating S3 setup...${x}"
			echo
		fi

	done
	clear

	if [ $restoreintent = "y" ]
	then
		echo "${b}You previously set up S3 and also specified that you're setting up this machine to restore a previous aenigma installation from another machine.${x}"
		echo
		echo "${b}If you intend to restore from S3 you must have your encryption passphrase handy now as you were reminded upon initial installation on your old machine.${x}"
		echo
		read -rp "${b}Do you have your S3 encryption passphrase ready to specify now? (Y/n): ${x}" -n 1
		echo
		if [[ ! $REPLY =~ ^[Nn]$ ]]
		then

			defined=n
			until [ $defined = "y" ]
			do
				newbackupspw=""
				until [ ! $newbackupspw = "" ]
				do
					read -rp "${b}Ok, paste your S3 encryption passphrase here: " newbackupspw
					echo
				done
				valid=n
				until [ $valid = "y" ]
				do
					read -n 1 -rp "${b}Is | $newbackupspw | correct? (Y/n/e[xit]) ${x}" answer;
					case $answer in
					"")
						echo
						valid=y
						defined=y
						;;
					y)
						echo -e "\\n"
						valid=y
						defined=y
						;;
					n)
						echo -e "\\n"
						echo "${b}Ok, then please try again...${x}"
						echo
						valid=y
						defined=n
						;;
					e)
						echo -e "\\n"
						echo "${b}Exiting...${x}"
						echo
						exit
						;;
					*)
						echo -e "\\n"
						echo "${r}${b}Invalid option. Retry...${x}"
						echo
						valid=n
						defined=n
						;;
					esac
				done
			done
			echo "${b}Ok, using | $newbackupspw | as your S3 backups encryption passphrase.${x}"
			echo
			echo "$newbackupspw" > "$configdir"/backupspw
			backupspw=$newbackupspw

		else

			echo "${b}Ok, blocking S3 restores until you manually specify your old S3 backups encryption passphrase here:${x}"
			echo
			echo "${b} | $configdir/backupspw | ${x}"
			echo
			echo "${b}If you've lost your encryption passphrase, your S3 backups are also lost. Look for a local backup you might have from your old machine to restore your previous instance.${x}"
			echo
			touch $configdir/blocks3restores
			read -rp "${b}[press enter to continue reading...]${x}"
			clear

		fi

	else

		if [ ! -f $configdir/backupspw ]
		then
			touch $configdir/backupspw
			chmod 700 $configdir/backupspw
			generatedpw="$(pwgen 42 1)"
			echo "$generatedpw" > "$configdir"/backupspw
		else
			chmod 700 $configdir/backupspw # In case someone accidentally modified permissions on $configdir
		fi

		backupspw="$(cat $configdir/backupspw)"

		echo "${b}Your S3 backups encryption passphrase is:${x}"
		echo
		echo "${g}${b} | $backupspw | ${x}"
		echo
		echo "${b}Make sure you keep it saved in a safe location OUTSIDE of this machine and NOT on the S3 file storage server.${x}"
		echo
		echo "${r}${b}You will NOT be able to restore ANY backup without this passphrase.${x}"
		echo
		echo "${b}This is your only chance to save this passphrase. If you don't do it now and this machine's data is lost, so will be your backups.${x}"
		echo
		read -rp "${b}[press enter to continue reading...]${x}"
		clear

	fi

fi



if [ $addTLSmode = "here" ]
then
	declare -a dnsarray=(
                "hostname"
                "domain"
		"XMPP"
		"SRV"
                )
elif [ $addTLSmode = "elsewhere" ]
then
        declare -a dnsarray=(
                "hostname"
		"XMPP"
		"SRV"
                )
else
	declare -a dnsarray=(
                "hostname"
		"XMPP"
                )
fi

if [ $ipv6avail = "y" ]
then
        declare -a iparray=(
                "v4"
                "v6"
                )
else
        declare -a iparray=(
                "v4"
                )
fi

for dnstype in "${dnsarray[@]}"
do

	if [ "$dnstype" = "hostname" ]
	then
		dnschecktype=$hostname
	else
		dnschecktype=$domain
	fi

	srvdone=n

	for ipversion in "${iparray[@]}"
	do

		if [ $srvdone = n ]
		then

			if [ ! "$dnstype" = "SRV" ]
			then
				echo "${b}Now let's make sure your $dnstype IP$ipversion DNS settings are correct.${x}"
				echo
			else
				echo "${b}Since you've chosen option 1, your domain is different from your hostname.${x}"
				echo
				echo "${b}Therefore, we have to set some DNS 'SRV' records which will direct XMPP connections for $domain to this server.${x}"
				echo
				echo "${b}Now let's make sure your XMPP SRV records are correct.${x}"
				echo
			fi

			if [ "$dnstype" = "hostname" ]
			then
				declare -A digarray=(
					[HN]=""
					[www]="www."
				)
			elif [ "$dnstype" = "domain" ]
			then
				declare -A digarray=(
					[HN]=""
					[www]="www."
				)
			elif [ "$dnstype" = "XMPP" ]
			then
				declare -A digarray=(
					[xc]="xc."
					[xe]="xe."
					[xi]="xi."
					[xm]="xm."
					[xp]="xp."
					[xu]="xu."
					[wu]="www.xu."
				)
			elif [ "$dnstype" = "SRV" ]
			then
				declare -A digarray=(
					[sj]="_jabber._tcp."
					[ss]="_xmpp-server._tcp."
					[sc]="_xmpp-client._tcp."
				)
			fi

			# [xc]="XMPP messaging groups [aka conferences / MUCs in XMPP lingo]."
			# [xu]="XMPP HTTP uploads."
			# [xe]="the ejabberd MOD_ECHO module."
			# [xp]="the ejabberd MOD_PUBSUB module."
			# [xi]="join channels on IRC servers."

			digarrayiter=0

			for i in "${!digarray[@]}"
			do

				digarrayiter=$((digarrayiter + 1))

				if [ ! "$dnstype" = "SRV" ]
				then
					echo "${b}$digarrayiter] Now checking the ${digarray[$i]}$dnschecktype DNS record in IP$ipversion...${x}"
					echo
				else
					echo "${b}$digarrayiter] Now checking the ${digarray[$i]}$dnschecktype SRV record...${x}"
					echo
				fi

				accept=n
				until [ $accept = "y" ]
				do

					if [ ! "$dnstype" = "SRV" ]
					then
						if [ "$ipversion" = "v4" ]
						then
				                	thisip=$thisipv4
							digresult="$(getent ahostsv4 "${digarray[$i]}""$dnschecktype". | head -1 |sed 's/ .*//')"
				                	rectype="A"
						else
				                	thisip=$thisipv6
				                	digresult="$(getent ahostsv6 "${digarray[$i]}""$dnschecktype". | grep -v "$thisipv4" | head -1 | sed 's/ .*//')"
				                	rectype="AAAA"
						fi
					else
						if [ ! "${digarray[$i]}" = "_xmpp-client._tcp." ]
						then
							thisip="0 0 5269 $hostname."
						else
							thisip="0 0 5222 $hostname."
						fi
						digresult="$(dig +short -t srv "${digarray[$i]}""$domain")"
						rectype="SRV"
					fi

					if [ -z "$digresult" ]
					then

						if [ ! "$dnstype" = "SRV" ]
						then
							echo "${r}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to be at all set.${x}"
							echo
						else
							echo "${r}${b}The ${digarray[$i]}$dnschecktype SRV record does NOT appear to be at all set.${x}"
							echo
						fi

						echo "${b}Please ensure you set your DNS record as follows:${x}"
						echo
						echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
						echo
						if [ ! "${digarray[$i]}$dnschecktype" = "$hostname" ]
						then
							if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
							then
								if [ "$ipversion" = "v4" ]
								then
									echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
									echo
									echo -e "| ${digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
									echo
								fi
							fi
						fi
						result=notset
					else
						if [ "$digresult" = "$thisip" ]
						then

							if [ ! "$dnstype" = "SRV" ]
							then
								echo "${g}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record appears to resolve correctly to this server.${x}"
								echo
							else
								echo "${g}${b}The ${digarray[$i]}$dnschecktype SRV record appears to resolve correctly to this server.${x}"
								echo
							fi

							echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
							echo
							result=ok
						else

							if [ ! "$dnstype" = "SRV" ]
							then
								echo "${r}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to correctly resolve to this server.${x}"
								echo
							else
								echo "${r}${b}The ${digarray[$i]}$dnschecktype SRV record does NOT appear to correctly resolve to this server.${x}"
								echo
							fi

							echo "${b}This is the result of a DNS query for ${digarray[$i]}$dnschecktype:${x}"
							echo
							echo "$digresult"
							echo
							echo "${b}Please set it instead to:${x}"
							echo
							echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
							echo
							if [ ! "${digarray[$i]}$dnschecktype" = "$hostname" ]
							then
								if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
								then
									if [ "$ipversion" = "v4" ]
									then
										echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
										echo
										echo -e "| ${digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
										echo
									fi
								fi
							fi
							result=incorrect
						fi
					fi

					if [ ! $result = "ok" ]
					then
						valid=n
						until [ $valid = "y" ]
						do
							read -n 1 -rp "${b}Test again?${x} (${b}Y${x}[es]/${b}s${x}[kip]/${b}e${x}[xit]) " answer;
							case $answer in
							"")
								echo
								valid=y
								accept=n
								;;
							y)
								echo -e "\\n"
								valid=y
								accept=n
								;;
							s)
								echo -e "\\n"
								echo "${b}Skipping DNS check for this record...${x}"
								echo
								valid=y
								accept=y
								;;
							e)
								echo -e "\\n"
		        					echo "${b}Exiting...${x}"
		        					echo
		        					exit
		        					;;
							*)
								echo -e "\\n"
								echo "${b}Invalid option. Retry...${x}"
		        					echo
								valid=n
								accept=n
				        			;;
							esac
						done
					else
						accept=y
					fi
					clear

				done

			done

			if [ ! "$dnstype" = "SRV" ]
			then
				echo "${b}Finished checking your $dnstype IP$ipversion DNS settings.${x}"
				echo
			else
				echo "${b}Finished checking your XMPP SRV records.${x}"
				echo
				srvdone=y
			fi

		fi

	done

done
clear

echo "${b}Now setting UFW rules...${x}"
echo

ufw allow 5222
ufw allow 5223
ufw allow 5269
ufw allow 5444
ufw allow 80
ufw allow 443

echo
echo "${b}Finished setting UFW rules.${x}"
echo

echo "${b}Now installing easyengine...${x}"
echo
wget -qO ee rt.cx/ee
bash ee || true
rm ee
source /etc/bash_completion.d/ee_auto.rc
echo
echo "${b}Finished installing easyengine.${x}"
echo

echo "${b}Now creating easyengine site for $hostname, generating its TLS certificate, and installing it...${x}"
echo
ee site create "$hostname" || true
echo
echo "${b}Finished creating easyengine site for $hostname.${x}"
echo

echo "${b}Now setting custom nginx config for $hostname...${x}"
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/hostname.conf
cp "$sourcedir"/conf/nginx/hostname.conf /etc/nginx/sites-available/"$hostname"
service nginx reload
echo "${b}Finished setting custom nginx config for $hostname.${x}"
echo

echo "${b}Now updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
echo
ee site update "$hostname"  --le --experimental || true
if [ ! -f /etc/letsencrypt/live/"$hostname"/fullchain.pem ]
then
	echo "${r}${b}There was an issue provisioning the TLS certificate for $hostname with LetsEncrypt.${x}"
	echo
	echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	echo
	echo "${b}Exiting...${x}"
	echo
	exit
fi
echo
echo "${b}Finished updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
echo

echo "${b}Now creating all-in-one TLS file for $hostname for ejabberd...${x}"
echo
touch $tlsdir/hostname.pem
cat /etc/letsencrypt/live/"$hostname"/privkey.pem > "$tlsdir"/hostname.pem
cat /etc/letsencrypt/live/"$hostname"/fullchain.pem >> "$tlsdir"/hostname.pem
echo "${b}Finished creating all-in-one TLS file for $hostname for ejabberd.${x}"
echo

echo "${b}Now setting index.html in docroot for $hostname...${x}"
echo
cp "$sourcedir"/conf/web/hostname/index.html /var/www/"$hostname"/htdocs/
echo "${b}Finished setting index.html in docroot for $hostname.${x}"
echo



echo "${b}Now creating easyengine site for xu.$domain, generating its TLS certificate, and installing it...${x}"
echo
ee site create xu."$domain" || true
echo
echo "${b}Finished creating easyengine site for xu.$domain.${x}"
echo

echo "${b}Now setting custom nginx config for xu.$domain...${x}"
echo
sed -i "s/example.im/xu.${domain}/g" $sourcedir/conf/nginx/xu.conf
cp "$sourcedir"/conf/nginx/xu.conf /etc/nginx/sites-available/xu."$domain"
service nginx reload
echo "${b}Finished setting custom nginx config for xu.$domain.${x}"
echo

echo "${b}Now updating easyengine site xu.$domain to TLS encrypted with LetsEncrypt...${x}"
echo
ee site update xu."$domain"  --le --experimental || true
if [ ! -f /etc/letsencrypt/live/xu."$domain"/fullchain.pem ]
then
	echo "${r}${b}There was an issue provisioning the TLS certificate for xu.$domain with LetsEncrypt.${x}"
	echo
	echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	echo
	echo "${b}Exiting...${x}"
	echo
	exit
fi
echo
echo "${b}Finished updating easyengine site xu.$domain to TLS encrypted with LetsEncrypt...${x}"
echo

echo "${b}Now creating all-in-one TLS file for xu.$domain for ejabberd...${x}"
echo
touch $tlsdir/xu.pem
cat /etc/letsencrypt/live/xu."$domain"/privkey.pem > "$tlsdir"/xu.pem
cat /etc/letsencrypt/live/xu."$domain"/fullchain.pem >> "$tlsdir"/xu.pem
echo "${b}Finished creating all-in-one TLS file for xu.$domain for ejabberd.${x}"
echo



if [ $addTLSmode = "here" ]
then

	echo "${b}Since you've chosen to provision a TLS certificate for $domain on this server, now we're now going to do so.${x}"
 	echo

	echo "${b}Now creating easyengine site for $domain, generating its TLS certificate, and installing it...${x}"
	echo
	ee site create "$domain" || true
	echo
	echo "${b}Finished creating easyengine site for $domain.${x}"
	echo

	echo "${b}Now setting custom nginx config for $domain...${x}"
	echo
	sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/domain.conf
	cp "$sourcedir"/conf/nginx/domain.conf /etc/nginx/sites-available/"$domain"
	service nginx reload
	echo "${b}Finished setting custom nginx config for $domain.${x}"
	echo

	echo "${b}Now updating easyengine site $domain to TLS encrypted with LetsEncrypt...${x}"
	echo
	ee site update "$domain"  --le --experimental || true
	if [ ! -f /etc/letsencrypt/live/"$domain"/fullchain.pem ]
	then
		echo "${r}${b}There was an issue provisioning the TLS certificate for $domain with LetsEncrypt.${x}"
		echo
		echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
		echo
		echo "${b}Exiting...${x}"
		echo
		exit
	fi
	echo
	echo "${b}Finished updating easyengine site $domain to TLS encrypted with LetsEncrypt...${x}"
	echo

	echo "${b}Now creating all-in-one TLS file for $domain for ejabberd...${x}"
	echo
	touch $tlsdir/domain.pem
	cat /etc/letsencrypt/live/"$domain"/privkey.pem > "$tlsdir"/domain.pem
	cat /etc/letsencrypt/live/"$domain"/fullchain.pem >> "$tlsdir"/domain.pem
	domtlscertloc=$tlsdir/domain.pem
	echo "${b}Finished creating all-in-one TLS file for $domain for ejabberd...${x}"
	echo

	echo "${b}Now setting index.html in docroot for $domain...${x}"
	echo
	cp "$sourcedir"/conf/web/domain/index.html /var/www/"$domain"/htdocs/
	echo "${b}Finished setting index.html in docroot for $domain.${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS version of the $domain site...${x}"
	echo
	sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/ssl-domain.conf
	cp "$sourcedir"/conf/nginx/ssl-domain.conf /var/www/"$domain"/conf/nginx/ssl.conf
	echo "${b}Finished adding IPv6 support to the HTTPS version of the $domain site...${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS redirect for the $domain site...${x}"
	echo
	sed -i "s/example.im/${domain}/g" $sourcedir/conf/nginx/force-ssl-domain.conf
	cp "$sourcedir"/conf/nginx/force-ssl-domain.conf /etc/nginx/conf.d/force-ssl-"$domain".conf
	echo "${b}Finished adding IPv6 support to the HTTPS redirect for the $domain site...${x}"
	echo

fi

### only add IPv6 to hostname site after LE TLS cert has been provisioned for all sites otherwise .well-known check will fail due to wrong webroot

echo "${b}Now adding IPv6 support to the HTTPS version of the $hostname site...${x}"
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/ssl-hostname.conf
cp "$sourcedir"/conf/nginx/ssl-hostname.conf /var/www/"$hostname"/conf/nginx/ssl.conf
echo "${b}Finished adding IPv6 support to the HTTPS version of the $hostname site...${x}"
echo

echo "${b}Now adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
echo
sed -i "s/example.im/${hostname}/g" $sourcedir/conf/nginx/force-ssl-hostname.conf
cp "$sourcedir"/conf/nginx/force-ssl-hostname.conf /etc/nginx/conf.d/force-ssl-"$hostname".conf
echo "${b}Finished adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
echo

echo "${b}Now adding IPv6 support to the HTTPS version of the xu.$domain site...${x}"
echo
sed -i "s/example.im/xu.${domain}/g" $sourcedir/conf/nginx/ssl-xu.conf
cp "$sourcedir"/conf/nginx/ssl-xu.conf /var/www/xu."$domain"/conf/nginx/ssl.conf
echo "${b}Finished adding IPv6 support to the HTTPS version of the xu.$domain site...${x}"
echo

echo "${b}Now adding IPv6 support to the HTTPS redirect for the xu.$domain site...${x}"
echo
sed -i "s/example.im/xu.${domain}/g" $sourcedir/conf/nginx/force-ssl-xu.conf
cp "$sourcedir"/conf/nginx/force-ssl-xu.conf /etc/nginx/conf.d/force-ssl-xu."$domain".conf
echo "${b}Finished adding IPv6 support to the HTTPS redirect for the xu.$domain site...${x}"
echo

service nginx restart



echo "${b}Now creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml...${x}"
echo
mkdir -p /etc/ejabberd/
touch /etc/ejabberd/ejabberd.yml
sed -i "s/example.im/${domain}/g" $sourcedir/conf/ejabberd/ejabberd.yml
sed -i "s/hostname.im/${hostname}/g" $sourcedir/conf/ejabberd/ejabberd.yml
if [ $configoption = 1 ]
then
sed -i "s|example.im|${domain}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
sed -i "s|pathtofile|${domtlscertloc}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
sed -i '/## aenigma_host_config_domain_placeholder_start:/,/## aenigma_host_config_domain_placeholder_end:/{//!d}' $sourcedir/conf/ejabberd/ejabberd.yml
sed -i "/## aenigma_host_config_domain_placeholder_start:/ r $sourcedir/conf/ejabberd/ejabberd-tlsaddition-domain.txt" $sourcedir/conf/ejabberd/ejabberd.yml
fi
#sed -i "s|example.im|xu.${domain}|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition-xu.txt
#sed -i "s|pathtofile|${tlsdir}/xu.pem|g" $sourcedir/conf/ejabberd/ejabberd-tlsaddition-xu.txt
#sed -i '/## aenigma_host_config_xu_placeholder_start:/,/## aenigma_host_config_xu_placeholder_end:/{//!d}' $sourcedir/conf/ejabberd/ejabberd.yml
#sed -i "/## aenigma_host_config_xu_placeholder_start:/ r $sourcedir/conf/ejabberd/ejabberd-tlsaddition-xu.txt" $sourcedir/conf/ejabberd/ejabberd.yml
cp $sourcedir/conf/ejabberd/ejabberd.yml /etc/ejabberd/ejabberd.yml
echo "${b}Finished creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml.${x}"
echo

echo "${b}Now creating uploads directory...${x}"
echo
mkdir -p /etc/ejabberd/uploads/
echo "${b}Finished creating uploads directory.${x}"
echo



echo "${b}Now creating HTTP fileserver directory...${x}"
echo
mkdir -p /var/www/ejabberd/
echo "${b}Finished creating HTTP fileserver directory.${x}"
echo



echo "${b}Now creating logfile...${x}"
echo
mkdir -p /var/log/ejabberd/
touch /var/log/ejabberd/www_access.log
echo "${b}Finished creating logfile.${x}"
echo



echo "${b}Now copying tools directory...${x}"
echo
mkdir -p $toolsdir
cp -r $sourcedir/tools/* $toolsdir/
echo "${b}Finished copying tools directory.${x}"
echo



echo "${b}Now adding backup script to daily crontab...${x}"
echo
touch /etc/cron.daily/aenigma-backup
chmod 755 /etc/cron.daily/aenigma-backup
echo -e '#!/bin/bash' > /etc/cron.daily/aenigma-backup
echo >> /etc/cron.daily/aenigma-backup
echo "bash /root/openspace42/aenigma/tools/aenigma-backup" >> /etc/cron.daily/aenigma-backup
echo "${b}Finished adding backup script to daily crontab...${x}"
echo



echo "${b}Now installing SSLH...${x}"
echo
/usr/sbin/service sslh stop &> /dev/null || true
sshport="$(cat $basedir/DFBS/ssh-port)"
apt-get -y install libwrap0-dev libconfig8-dev
rm -r $tmpdir/sslh &> /dev/null || true
git clone https://github.com/yrutschle/sslh $tmpdir/sslh
( cd $tmpdir/sslh && make install && make && cp sslh-select /usr/local/sbin/sslh )
#mkdir -p /etc/sslh/
sed -i "s|thisipv4-var|${thisipv4}|g" $sourcedir/conf/sslh/etc-sslh-v1.18
if [ $ipv6avail = "y" ]
then
	sed -i "s|#ipv6_comma|,|g" $sourcedir/conf/sslh/etc-sslh-v1.18
	sed -i "s|#ipv6_line||g" $sourcedir/conf/sslh/etc-sslh-v1.18
	sed -i "s|thisipv6-var|${thisipv6}|g" $sourcedir/conf/sslh/etc-sslh-v1.18
else
	sed -i "s|#ipv6_comma||g" $sourcedir/conf/sslh/etc-sslh-v1.18
	sed -i "s|#ipv6_line|#|g" $sourcedir/conf/sslh/etc-sslh-v1.18
fi
sed -i "s|domain-var|${domain}|g" $sourcedir/conf/sslh/etc-sslh-v1.18
sed -i "s|sshport-var|${sshport}|g" $sourcedir/conf/sslh/etc-sslh-v1.18
cp $sourcedir/conf/sslh/etc-sslh-v1.18 /etc/sslh.cfg
cp $sourcedir/conf/sslh/etc.init.d.sslh /etc/init.d/sslh
chmod +x /etc/init.d/sslh
update-rc.d sslh defaults
systemctl daemon-reload
#cp $sourcedir/conf/sslh/etc-default-sslh-v1.18 /etc/default/sslh
rm -r $tmpdir/sslh
mkdir -p /var/run/sslh
touch /var/run/sslh/sslh.pid
service sslh restart
echo
echo "${b}Finished installing SSLH.${x}"
echo



echo "${b}Now ensuring DPKG is available...${x}"
echo
i=0
tput sc
while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
	case $((i % 4)) in
	0 ) j="-" ;;
	1 ) j="\\" ;;
	2 ) j="|" ;;
	3 ) j="/" ;;
	esac
	tput rc
	echo -en "\\r[$j] ${b}Waiting for other software managers to finish...${x}"
	echo
	sleep 0.5
	((i=i+1))
done
echo "${b}DPKG available. Continuing...${x}"
echo



echo "${b}Now installing ejabberd...${x}"
echo
currdistro="$(lsb_release --codename | cut -f2)"
apt-get -y install apt-transport-https
echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
apt-get update
export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd
echo
echo "${b}Finished installing ejabberd.${x}"
echo



echo "${b}Now securing permissions...${x}"
echo

chown -R ejabberd:ejabberd $tlsdir
chmod -R 700 $tlsdir

chown -R ejabberd:ejabberd /etc/ejabberd/uploads/
chmod -R 755 /etc/ejabberd/uploads/

chown -R ejabberd:ejabberd /var/www/ejabberd/
chmod -R 755 /var/www/ejabberd/

echo "${b}Finished securing permissions.${x}"
echo



echo "${b}Now stopping ejabberd...${x}"
echo
/usr/sbin/service ejabberd stop
sleep 8
echo "${b}Finished stopping ejabberd.${x}"
echo

echo "${b}Now starting ejabberd...${x}"
/usr/sbin/service ejabberd start
echo
sleep 8
/usr/sbin/ejabberdctl status
echo
echo "${b}Finished starting ejabberd.${x}"
echo



echo "${b}Now registering ejabberd admin user [if it doesn't yet exist]...${x}"
echo
ejbdadminpw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
/usr/sbin/ejabberdctl register admin "$domain" "$ejbdadminpw" &> /dev/null || true
echo "${b}Finished registering ejabberd admin user.${x}"
echo
clear

if [ -f $configdir/ejabberdadminpwset ]
then
	read -rp "${b}Leave ejabberd admin user password the same as previously set? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Skipping ejabberd admin user password reset.${x}"
		echo
		ejbdadminpwreset=n
	else
		echo
		echo "${b}Ok, resetting ejabberd admin user password to: | $ejbdadminpw | ${x}"
		echo
		/usr/sbin/ejabberdctl change_password admin "$domain" "$ejbdadminpw"
		ejbdadminpwreset=y
	fi
else
	touch $configdir/ejabberdadminpwset
	ejbdadminpwreset=y
fi



echo "${b}Now updating ejabberd's module repo...${x}"
echo
/usr/sbin/ejabberdctl modules_update_specs
echo "${b}Finished updating ejabberd's module repo...${x}"
echo



echo "${b}Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@$domain can see 'everybody' and 'all online']...${x}"
echo
/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
echo "${b}Finished creating shared roster groups.${x}"
echo
clear



echo "${g}${b}You can finally log in:${x}"
echo
echo "${b}https://$hostname${x}"
echo
echo "${b}admin@$domain${x}"
echo

if [ $ejbdadminpwreset = "y" ]
then
	echo "${b}$ejbdadminpw${x}"
	echo
else
	echo "${b}[your previously set password]${x}"
	echo
fi

read -rp "${b}[press enter to continue reading...]${x}"
clear



touch $configdir/installcomplete
echo "$currvers" > "$configdir"/installcomplete



if [ -f $tlsdir/dh.pem ]
then
	echo "${g}${b}DHparam file found. Skipping generation...${x}"
	echo
else
	echo "${b}One last thing: to make your TLS connections even more secure, you can generate a file called DH parameters file.${x}"
	echo
	echo "${b}To do so, simply answer yes, but be aware that this is a very time consuming cryptographic operation, although it must only be performed once.${x}"
	echo
	read -rp "${b}Generate openssl DHparams file? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		echo "${b}Ok, proceeding with DHparams file generation...${x}"
		echo
		openssl dhparam -out $tlsdir/dh.pem.incomplete 4096
		mv $tlsdir/dh.pem.incomplete $tlsdir/dh.pem
		echo
	else
		echo
		echo "${b}Skipping DHparams generation.${x}"
		echo
		echo "${b}You can always generate them at a later time by executing:${x}"
		echo
		echo "${b}openssl dhparam -out $tlsdir/dh.pem.incomplete 4096${x}"
		echo
		echo "${b}[and making sure you let the command run until it exits]. Once it's done, execute:${x}"
		echo
		echo "${b}mv $tlsdir/dh.pem.incomplete $tlsdir/dh.pem${x}"
		echo
		/usr/sbin/service ejabberd restart
	fi
	echo "${b}Finished generating DHparams.${x}"
	echo
fi
sleep 1
clear

echo "${b}Now removing installer directory...${x}"
echo
echo "Run ${b}git clone https://github.com/openspace42/aenigma${x} once again to download the latest installer!"
echo
echo "${b}Finished removing installer directory...${x}"
echo

rm -r aenigma/

echo "${g}${b}aenigma installation complete!${x}"
echo

exit
