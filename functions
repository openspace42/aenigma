#!/bin/bash

### openspace bash-framework v0.1.4 [https://github.com/openspace42/bash-framework]

os_bash_functions_version=0.2.0

################################################################################

define_vars() {

	############################################################################
	######################## Insert your variables here ########################
	############################################################################

	proj_name="aenigma"
	short_name="aenigma"
	author_name="openspace42"

	### Set this to `y` if your project stores no data on end users' machines that could go lost during a re-install or update
	skip_install_time_backup=n

	### Set this to the directory that has the most impactful size when performing a backup [such as `/var/www/` for nginx-related projects]
	backup_ref_dir="/var/lib/ejabberd"

	############################################################################
	############################################################################
	############################################################################

	os-define_vars

}

################################################################################

check_root() {

	if [[ $EUID -ne 0 ]]
	then
		echo "${r}${b}This script must be run as root${x}"
		echo
		echo "${b}Exiting...${x}"
		echo
		exit 1
	fi

}

download_os_functions() {

	clone_author=openspace42
	clone_name=bash-functions
	base_dir=/root/$clone_author
	clone_dir=$base_dir/$clone_name
	if [ -d $clone_dir ]
	then
		rm -r ${clone_dir:?}
	fi
	mkdir -p $base_dir
	( cd $base_dir && git clone https://github.com/$clone_author/$clone_name && cd $clone_name && if [ ! ${bleeding_edge_bf-null} = "-b" ]; then git checkout tags/v$os_bash_functions_version; fi &> /dev/null )

}

source_os_functions() {

	for f in /root/openspace42/bash-functions/functions/*
	do
		. $f
	done

}

################################################################################

################################################################################
######################## Insert project functions here #########################
################################################################################

aenigma_xmpp_intro() {

	echo "0] First of all, a little introduction on how XMPP actually works"
	echo
	echo "XMPP works a little bit like email. You can have a domain [amsterdamhacklab.xyz] and receive email for that domain on a server located at mx01.amsterdamhacklab.xyz, by using the appropriate DNS configuration, and also have other servers [webserver, mapserver, etc...] on other subdomains. In that case, a DNS MX record tells sending servers to direct mail intended for amsterdamhacklab.xyz to mx01.amsterdamhacklab.xyz."
	echo
	echo "In the same way, the XMPP server for amsterdamhacklab.xyz can be located at xmpp.amsterdamhacklab.xyz and a DNS SRV record tells any sending servers that XMPP for that domain [i.e. a message directed to mark@amsterdamhacklab.xyz] is handled by the server located at xmpp.amsterdamhacklab.xyz."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "1] Now, if the domain for which you're setting up your new aenigma server is a domain connected to a bigger project, for which XMPP is just another way of getting in touch with you, definitely set things up like this by using the first option."
	echo
	echo "This will give you working @domain.tld xmpp account addresses, but the aenigma server will reside at subdomain.domain.tld, as in the following example."
	echo
	echo "Main domain:          amsterdamhacklab.xyz."
	echo "Website:              amsterdamhacklab.xyz / www.amsterdamhacklab.xyz [hosted by another server]."
	echo "Your XMPP address:    mark@amsterdamhacklab.xyz."
	echo "XMPP server:          xmpp.amsterdamhacklab.xyz"
	echo
	echo "PROs:                 a] clean addresses [no mark@xmpp.amsterdamhacklab.xyz stuff]"
	echo "                      b] more logical setup."
	echo "CONs:                 a] requires TLS [SSL] certificate for the top level domain [amsterdamhacklab.xyz]"
	echo "                         to be copied over to your new aenigma server [not hard at all, can be automated, see below]"
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "2] If instead your domain [i.e. aenigmapod42.im] is only intended to be used for your shiny new aenigma server, and you don't need other, different servers [a webserver for instance] managing different aspects of your project, you can do as so:"
	echo
	echo "Set your aenigma server to be located directly at your top level domain, therefore responding directly to amsterdamhacklab.xyz."
	echo
	echo "Your server hostname:  aenigmapod42.im"
	echo "Your addresses:        mark@aenigmapod42.im."
	echo
	echo "PROs:                  a] clean addresses"
	echo "                       b] no separate TLS certificate needed."
	echo "CONs:                  a] your domain must be logically dedicated to your aenigma server"
	echo "                          and not to a wider project."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "3] In a third, although NOT suggested case, if you have a domain tied to a wider project [i.e. amsterdamhacklab.xyz] but you don't mind having longer and more complex XMPP account addresses [like mark@xmpp.amsterdamhacklab.xyz], you can choose the third option."
	echo
	echo "Your server hostname:  subdomain.domain.tld"
	echo "Your addresses:        mark@subdomain.domain.tld."
	echo
	echo "PROs:                  a] domain can be logically connected to other stuff and different servers"
	echo "                          with no separate TLS certificate needed."
	echo "CONs:                  a] longer and more complex addresses"
	echo "                       b] not logically 'clean'."
	echo
	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	echo "Now that you know how XMPP works, make your choice and let's get your brand new aenigma server up and running!"
	echo
	echo "----------------"
	echo

}

aenigma-add_ejabberd_repo() {

	currdistro="$(lsb_release --codename | cut -f2)"
	apt-get -y install apt-transport-https || true
	echo "deb https://apt.jabber.at $currdistro ejabberd" > /etc/apt/sources.list.d/jabber.at.list
	wget -qO- https://apt.jabber.at/gpg-key | apt-key add -
	apt-get update

}

aenigma-install_ejabberd_config() {

	echo "${b}Now creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml...${x}"
	echo

	ejab_cand_vers="$(apt-cache show ejabberd | grep Version | head -1 | sed "s|Version: ||" | cut -d ':' -f 2 | cut -f1 -d'-')"

	source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-$ejab_cand_vers.yml"

	if [ ! -f $source_ejab_conf_file ]
	then
		### Fallback to ejabberd.yml for v17.08 in case the ejabberd candidate install version isn't among the ones we have config files for
		source_ejab_conf_file="$source_dir/conf/ejabberd/ejabberd-17.08.yml"
	fi

	mkdir -p /etc/ejabberd/
	touch /etc/ejabberd/ejabberd.yml
	sed -i "s/example.im/${domain}/g" "$source_ejab_conf_file"
	sed -i "s/hostname.im/${hostname}/g" "$source_ejab_conf_file"
	if [ $config_option = 1 ]
	then
		sed -i "s|example.im|${domain}|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
		sed -i "s|pathtofile|${domain_tls_cert_location}|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt
		sed -i '/## aenigma_host_config_domain_placeholder_start:/,/## aenigma_host_config_domain_placeholder_end:/{//!d}' $source_dir/conf/ejabberd/ejabberd.yml
		sed -i "/## aenigma_host_config_domain_placeholder_start:/ r $source_dir/conf/ejabberd/ejabberd-tlsaddition-domain.txt" $source_dir/conf/ejabberd/ejabberd.yml
	fi
	#sed -i "s|example.im|xu.${domain}|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-xu.txt
	#sed -i "s|pathtofile|${tlsdir}/xu.pem|g" $source_dir/conf/ejabberd/ejabberd-tlsaddition-xu.txt
	#sed -i '/## aenigma_host_config_xu_placeholder_start:/,/## aenigma_host_config_xu_placeholder_end:/{//!d}' $source_dir/conf/ejabberd/ejabberd.yml
	#sed -i "/## aenigma_host_config_xu_placeholder_start:/ r $source_dir/conf/ejabberd/ejabberd-tlsaddition-xu.txt" $source_dir/conf/ejabberd/ejabberd.yml
	cp "$source_ejab_conf_file" /etc/ejabberd/ejabberd.yml
	echo "${b}Finished creating ejabberd directory and setting custom aenigma config to /etc/ejabberd/ejabberd.yml.${x}"
	echo

}

backup_locally_loop() {

	cp -r "$conf_dir" "$tmp_backup_dir"/conf/
	mkdir -p "$tmp_backup_dir"/data/
	/usr/sbin/ejabberdctl backup ejabberd-mnesia-backup
	mv /var/lib/ejabberd/ejabberd-mnesia-backup "$tmp_backup_dir"/data/ejabberd-mnesia-backup
	cp -r /etc/ejabberd/ "$tmp_backup_dir"/data/etc-ejabberd/
	cp -r /var/lib/ejabberd/ "$tmp_backup_dir"/data/var-lib-ejabberd/

}

restore_loop() {

	echo "${b}1] Now restoring aenigma config directory...${x}"
	echo

	rsync -aAXx --delete $restore_file_path/conf/ $conf_dir/

	echo "${b}2] Now restoring ejabberd database...${x}"
	echo

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        echo "${g}${b}ejabberd is already running. Continuing...${x}"
	        echo
	else
	        echo "${r}${b}ejabberd NOT running. Starting it now...${x}"
	        echo
	        echo "${b}Now starting ejabberd ...${x}"
	        /usr/sbin/service ejabberd start
	        echo
	        sleep 8
	        /usr/sbin/ejabberdctl
	        echo
	        sleep 1
	fi

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then
	        cd $restore_file_path/data/
		cp ./ejabberd-mnesia-backup /var/lib/ejabberd/
	        /usr/sbin/ejabberdctl restore ejabberd-mnesia-backup
		rm /var/lib/ejabberd/ejabberd-mnesia-backup
	        echo "${b}Successfully restored ejabberd database...${x}"
	        echo
	        sleep 8
	else
	        echo "${r}${b}ERROR: ejabberd STILL NOT running. Unable to restore database from backup.${x}"
	        echo
	        os-exit_function
	fi

	echo "${b}Now restoring ejabberd directories...${x}"
	echo

	echo "${b}Now stopping ejabberd for directory restore...${x}"
	echo
	/usr/sbin/service ejabberd stop
	sleep 8

	echo "${b}3] Now syncing ejabberd directories...${x}"
	echo

	rsync -aAXx --delete $restore_file_path/data/etc-ejabberd/ /etc/ejabberd/
	rsync -aAXx --delete $restore_file_path/data/var-lib-ejabberd/ /var/lib/ejabberd/

	echo "${b}Now setting permissions on ejabberd directories...${x}"
	echo

	chown -R ejabberd:ejabberd /etc/ejabberd/
	chown -R ejabberd:ejabberd /var/lib/ejabberd/

	echo "${b}Now starting ejabberd...${x}"
	/usr/sbin/service ejabberd start
	echo
	sleep 16
	/usr/sbin/ejabberdctl status
	echo
	sleep 1

	if (( $(ps -ef | grep -v grep | grep ejabberd | wc -l) > 0 ))
	then

	        echo "${g}${b}Restore complete!${x}"
	        echo
	        echo "${b}Now please verify your aenigma instance is running correctly and has everything you except it to.${x}"
	        echo

	        read -p "${b}Has your previous instance of aenigma been restored correctly? (Y/n): ${x}" -n 1 -r
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	                echo "${g}${b}Ok, all done!${x}"
	                echo
	                if [ -f $conf_dir/blocks3backups ]
	                then
				rm $conf_dir/blocks3backups
	                        echo "${b}Removing S3 backups lock since your restore has been successful.${x}"
	                        echo
	                        echo "${r}${b}This machine will now pick up where the old one left off and start backing up again to S3 and will overwrite all previous data stored on S3.${x}"
	                        echo
	                        echo "${b}If you've changed your mind and are NOT yet sure this restore was completely successful, simply:${x}"
	                        echo
	                        echo "${b} | touch $conf_dir/blocks3backups |"
	                        echo
	                        echo "${b}And remember to remove it as soon as you're done verifying this restored instance to then resume backups to S3!${x}"
	                        echo
	                        echo "${g}${b}All done for now.${x}"
	                        echo
	                fi
	        else
	                echo
	                echo "${b}Sorry about that, please collect all evidence you can find so and simply file an issue report at:${x}"
	        	echo
	        	echo "${b} | https://github.com/openspace42/aenigma/issues |${x}"
	        	echo
	        	echo "${b}Thank you in advance!${x}"
	                echo
	        fi

	else

	        echo "${r}${b}ERROR: ejabberd not running after restore. Please check ejabberd directories.${x}"
	        echo
	        echo "${b}Please collect all evidence you can find so and simply file an issue report at:${x}"
	        echo
	        echo "${b} | https://github.com/openspace42/aenigma/issues |${x}"
	        echo
	        echo "${b}Thank you in advance!${x}"
	        echo
	        echo "${b}Exiting...${x}"
	        echo
	        exit

	fi

	if [ -d "$restores_dir/local/" ]
	then
		rm -r "$restores_dir/local/"
	fi

	if [ -d "/root/$short_name-restore/" ]
	then
		rm -r "/root/$short_name-restore/"
	fi

	if [ -d "$tmpdir" ]
	then
		rm -r "${tmpdir:?}"
	fi

	if [ $bootstrapmode = "on" ]
	then
		echo "${b}Now that we're finished with the initial restore, it's time to re-run the install script and get this machine up and running with your old instance's files and settings${x}"
		echo
		echo "${b}Running install script now.${x}"
		echo
		echo "${r}${b}Should you exit the install script during its runtime, you can re-run it manually with:${x}"
		echo
		echo "${b} | bash $sourcedir/install.sh | ${x}"
		cd
		bash $sourcedir/install.sh
	fi

}

################################################################################
################################################################################
################################################################################

perform_installation() {

	############################################################################
	################### Add your install-time functions here ###################
	############################################################################

	os-check_sslh_connection

	os-check_distro_ubuntu16

	os-check_inception_run

	################################################################################

	os-apt_full_upgrade -e

	echo "${b}Now installing dependencies...${x}"
	echo
	hostname="$(cat /etc/hostname)"
	apt-add-repository ppa:duplicity-team/ppa -y
	apt-get update
	apt-get -y install duplicity python-pip s3cmd python-boto libpcre3-dev || true
	pip install --upgrade pip
	pip install boto
	echo
	echo "${b}Finished installing dependencies.${x}"
	echo

	mkdir -p "$tls_dir"
	mkdir -p "$temp_dir"

	################################################################################

	### Copy files to destination

	rsync -aAXx $source_dir/ $install_dir/ --include=tools*** --include=functions --exclude="*"

	### Skip intro if requested by user

	if [ $skip_intro = "n" ]
	then
	    aenigma_xmpp_intro
	fi

	### Set aenigma config option [described in intro]

	validate_input() {

	    case $input in
	        1|2|3)	config_option=$input
	        valid=y
	        ;;
	        *)	echo "${r}${b}Invalid setting for | config_option | in function | ${FUNCNAME[0]} |.${x}"
	        echo
	        valid=n
	        ;;
	    esac

	}

	os-set_option -o config_option -v y -d n -p xmpp

	### Set xmpp domain [only one supported for now] if config_option != 3
	### In the latter case the xmpp domain will match the machine hostname [see below]

	if [ ! $config_option = "3" ]
	then

	    echo "${b}Ok, you've chosen option $config_option.${x}"
	    echo

	    describe_setting() {

	        echo "${b}Now set your top level domain, which will also be the part after the @ in your XMPP account addresses:${x}"
	        echo

	    }

	    os-set_option -o domain -v n -d y -p xmpp

	    if [ $prev_val_outcome = "not-kept" ]
	    then
	        echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
	        echo
	        echo "${r}${b}WARNING:${x}"
	        echo
	        echo "${r}${b}Changing domains will not preserve any user accounts or data. It will revert this server to a fresh install.${x}"
	        echo
	        echo "${b}In the future, all user accounts and data for the previous domain might be recovered automatically if you ever re-run the install and select the old domain, but this hasn't been thoroughly tested yet.${x}"
	        echo
	        echo "${b}If you abort the domain change operation now, nothing will be deleted.${x}"
	        echo
	        echo "${b}- * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! - * - !!! -${x}"
	        echo
	        read -rp "${b}Are you absolutely sure you want to change the XMPP domain now? (y/N): ${x}" -n 1
	        echo
	        if [[ $REPLY =~ ^[Yy]$ ]]
	        then
	            echo "${b}Ok, proceeding...${x}"
	            echo
	        else
	            echo "${b}Ok, setting your domain back to the previous value | $prev_value |...${x}"
	            echo
	            domain="$prev_val"
	            echo "$prev_val" > "$opt_path"
	        fi
	    fi

	else

	    echo "${b}Ok, you've chosen option 3.${x}"
	    echo
	    echo "${b}Your domain [the part after the @ in your XMPP account addresses] will match your server hostname.${x}"
	    echo

	fi

	### Review and set machine hostname according to config_option

	curr_host_name="$(cat /etc/hostname)"

	if [ ! $config_option = "2" ]
	then

	    describe_setting() {

	        if [ $config_option = "1" ]
	        then
	            echo "${b}Your hostname must be a third level domain [subdomain] of either $domain or another domain.${x}"
	            echo
	        elif [ $config_option = "3" ]
	        then
	            echo "${b}Your hostname must be a third level domain [subdomain] of your main domain.${x}"
	            echo
	            echo "${b}Keep in mind that your hostname will also become your domain [the part after the @ in your XMPP account addresses].${x}"
	            echo
	        fi

	    }

	    os-set_option -o hostname -v n -d y -p /etc

	    if [ $config_option = "3" ]
	    then
	        domain=$hostname
	    fi

	else

	    echo "${b}Your hostname must be identical to your domain: $domain.${x}"
	    echo
	    echo "${b}Your current hostname is:${x}"
	    echo
	    echo " | $curr_host_name |"
	    echo
	    if [ "$curr_host_name" = "$domain" ]
	    then
	        echo "${g}${b}Your hostname matches your domain, all good!${x}"
	        echo
	    else
	        echo "${r}${b}Your hostname does NOT match the domain you've specified.${x}"
	        echo
	        echo "${b}Having chosen option 2, they must be identical.${x}"
	        echo
	        read -rp "${b}Do you want to set your hostname to match your domain? (Y/n): ${x}" -n 1
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	            echo "${b}Ok, setting hostname to match domain.${x}"
	            echo
	            echo "$domain" > /etc/hostname
	            echo "${b}New hostname set to | $domain | ${x}"
	            echo
	        else
	            echo
	            echo "${b}Not changing hostname. Exiting...${x}"
	            echo
	            exit
	        fi
	    fi

	    hostname="$(cat /etc/hostname)"

	fi
	clear

	### Review domain and hostname to see if the user approves

	echo "----------------"
	echo
	echo "${b}To make sure everything is correct:${x}"
	echo
	echo "1] Your ${b}XMPP domain${x} [the part after the @ in your XMPP account addresses] will be:"
	echo
	echo "${b} | ${g}$domain${x}${b} | ${x}"
	echo
	echo "2] And therefore an ${b}XMPP account address${x} will look as follows:"
	echo
	echo "${b} | ${g}mark@$domain${x}${b} | ${x}"
	echo
	echo "3] Your ${b}hostname${x}, the location on the internet of this server, will be:"
	echo
	echo "${b} | ${g}$hostname${x}${b} | ${x}"
	echo
	echo "4] And therefore your ${b}aenigma admin panel${x} will be located at:"
	echo
	echo "${b} | ${g}https://$hostname${x}${b} | ${x}"
	echo
	echo "----------------"
	echo

	read -rp "${b}Does everything look all right? (Y/n): ${x}" -n 1
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
	    echo "${b}Ok, continuing.${x}"
	    echo
	    touch $conf_dir/domain
	    echo "$domain" > $conf_dir/domain
	else
	    echo
	    echo "${b}Ok, no worries. You can re-run this script right now and make the correct choices. Exiting...${x}"
	    echo
	    exit
	fi
	clear

	### Set admin email address

	os-set_admin_email

	### Check internet connectivity and get public IP addresses

	os-get_public_ipv4

	os-check_ipv6_connectivity

	### Ask the user for the TLS cert for $domain or point it here to provision one locally

	additional_tls_mode="notset"

	if [ $config_option = 1 ]
	then

	    echo "${b}Having chosen config option 1, now it's time to set up the TLS [SSL] certificate that is valid for $domain on this machine.${x}"
	    echo

	    if [ -f $conf_dir/additional_tls_mode ]
	    then
	        prev_additional_tls_mode="$(cat $conf_dir/additional_tls_mode)"
	        case "$prev_additional_tls_mode" in
	            "elsewhere"|"here")
	            valid_prev_additional_tls_mode=y
	            ;;
	            *)
	            valid_prev_additional_tls_mode=n
	            ;;
	        esac
	    else
	        touch $conf_dir/additional_tls_mode
	        valid_prev_additional_tls_mode=n
	    fi

	    if [ $valid_prev_additional_tls_mode = "y" ]
	    then
	        echo "${g}${b}You previously specified that the A/AAAA DNS records for $domain point [or are supposed to point] | $prev_additional_tls_mode | ${x}"
	        echo
	        read -rp "${b}Is this still true? (Y/n): ${x}" -n 1
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	            additional_tls_mode=$prev_additional_tls_mode
	        else
	            echo
	            additional_tls_mode=not-yet-set
	        fi
	    else
	        additional_tls_mode=not-yet-set
	    fi

	    if [ $additional_tls_mode = "not-yet-set" ]
	    then

	        echo "The certificate file required for $short_name must be an all-in-one private key + certificate + chain file."
	        echo
	        echo "This means the file must include, in this order, the following:"
	        echo
	        echo "1] Private key; 2] Leaf [server] cert; 3] Certification Chain [Intermediate cert(s) + Root cert]"
	        echo
	        read -rp "${b}[press enter to continue reading...]${x}"
	        clear

	        echo "This certificate, if it already exists, resides on the server responding to $domain"
	        echo
	        echo "This is usually a web server, but check your domain/hosting infrastructure to see what server it is."
	        echo
	        echo "This is the IP to which your bare domain $domain is pointing to:"
	        echo
	        dig +noall +answer "$domain"
	        echo
	        echo "[If you see no output, then it might be misconfigured or not configured at all.]"
	        echo
	        read -rp "${b}[press enter to continue reading...]${x}"
	        clear

	        read -rp "${b}That said, is there ANOTHER [running] server that responds to $domain? (Y/n): ${x}" -n 1
	        echo
	        if [[ ! $REPLY =~ ^[Nn]$ ]]
	        then
	            read -rp "${b}Ok, does this server have a configured TLS [SSL] certificate up and running on it? (Y/n): ${x}" -n 1
	            echo
	            if [[ ! $REPLY =~ ^[Nn]$ ]]
	            then
	                read -rp "${b}Ok, is this a Linux server? (Y/n): ${x}" -n 1
	                echo
	                if [[ ! $REPLY =~ ^[Nn]$ ]]
	                then
	                    read -rp "${b}Ok, is this a Letsencrypt certificate? [if unsure, answer no] (Y/n): ${x}" -n 1
	                    echo
	                    if [[ ! $REPLY =~ ^[Nn]$ ]]
	                    then
	                        echo "${b}Very good, therefore access that server as root [or using sudo], and download this script in the root user's home directory:${x}"
	                        echo
	                        echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
	                        echo
	                        echo "${b}Now configure it to push its LE TLS cert to this server by following the instructions.${x}"
	                        echo
	                    else
	                        echo
	                        echo "${b}Ok, no problem, you can adapt this script:${x}"
	                        echo
	                        echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
	                        echo
	                        echo "${b}To have it fetch and concatenate your existing private key, TLS cert, and certification chain on the other server and push the resulting all-in-one file here periodically.${x}"
	                        echo
	                        echo "${b}Follow the instructions and adapt the paths to the existing TLS certs and private key.${x}"
	                        echo
	                    fi
	                else
	                    echo "${b}Ok, no problem, find your TLS certificate and related files on the other server and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!].${x}"
	                    echo
	                fi
	            else
	                read -rp "${b}Ok, no problem. Is this server a linux server? (Y/n): ${x}" -n 1
	                echo
	                if [[ ! $REPLY =~ ^[Nn]$ ]]
	                then
	                    echo "${b}Very good. You can therefore install letsencrypt on the other server, generate a cert for $domain, and copy it over here with this script:${x}"
	                    echo
	                    echo "${b}https://github.com/nikksno/LetsEncrypt-Cert-Push${x}"
	                    echo
	                else
	                    echo "${b}Ok, no problem, get a TLS certificate, install it and its related files on the other server, and make a simple script to periodically concatenate your existing private key, TLS cert, and certification chain on the other server and send the resulting all-in-one file over to this server, or copy it here manually [and remember to copy it over again every time you renew the cert!].${x}"
	                    echo
	                fi
	            fi

				read -rp "${b}[press enter to continue reading...]${x}"
				clear

	            additional_tls_mode="elsewhere"
	            echo "elsewhere" > $conf_dir/additional_tls_mode

	        else

	            echo
	            echo "${b}Ok, so we'll point $domain to this server and provision a TLS certificate for it on this very server.${x}"
	            echo
	            echo "If you ever add a new server to respond to $domain [a webserver for instance], simply make sure you periodically send the TLS certificate you'll generate on the new server back here, either by using this script on the new server:"
	            echo
	            echo "https://github.com/nikksno/LetsEncrypt-Cert-Push"
	            echo
	            echo "[or an adaptation of it] or by doing some other manual scripting that periodically fetches the TLS cert and all of its related files on the other server, concatenates your private key, TLS cert, and certification chain on the other server, and sends the resulting all-in-one file over to this server, [and does so again every time you renew the cert!]."
	            echo
	            echo "For now, no need to worry about that."
	            echo
	            read -rp "${b}[press enter to continue reading...]${x}"
	            clear

	            echo "${b}Let's point $domain and www.$domain to this server for the time being.${x}"
	            echo
	            echo "This is required for the TLS certificate we'll be generating shortly on this server."
	            echo
	            echo "The DNS checks we'll be running shortly will guide you through these settings as well."
	            echo

	            additional_tls_mode="here"
	            echo "here" > $conf_dir/additional_tls_mode

	        fi

	    fi

	    if [ $additional_tls_mode = "elsewhere" ]
	    then

	        if [ -f $tls_dir/$domain.pem ]
	        then
	            echo "${g}${b}External TLS certificate for $domain found in | $tls_dir/$domain.pem |."
	            echo
				sleep 1
	        else
	            echo "${b}Now, in whatever way you've installed or copied to this server the all-in-one TLS cert file for $domain, it's time to place it inside the  | $tls_dir | directory named as | $domain.pem |.${x}"
	            echo
	            echo "${b}Place it there now ensuring its full path is indeed | $tls_dir/$domain.pem |.${x}"
	            echo
	            read -rp "${b}[press enter when ready...]${x}"
	            clear
	            exists=n
	            until [ $exists = "y" ]
	            do
	                if [ -f  $tls_dir/$domain.pem ]
	                then
	                    echo "${g}${b}External TLS certificate for $domain found in | $tls_dir/$domain.pem |."
	                    echo
	                    exists=y
	                else
	                    echo "${r}${b}External TLS certificate for $domain NOT found in | $tls_dir/$domain.pem |."
	                    echo
	                    echo "${b}Please ensure you've correctly copied the certificate inside the directory and named it as above.${x}"
	                    echo
	                    read -rp "${b}[press enter when ready to try again...]${x}"
	                    clear
	                    exists=n
	                fi
	            done
	        fi

	        domain_tls_cert_location="$tls_dir/$domain.pem"
	        echo "$domain_tls_cert_location" > "$conf_dir/domain_tls_cert_location"

	    fi

	fi
	clear

	### Setup backup restore

	os-setup_backup_restore

	### Perform DNS checks

	if [ $additional_tls_mode = "here" ]
	then
	    declare -a dnsarray=(
	    "hostname"
	    "domain"
	    "XMPP"
	    "SRV"
	    )
	elif [ $additional_tls_mode = "elsewhere" ]
	then
	    declare -a dnsarray=(
	    "hostname"
	    "XMPP"
	    "SRV"
	    )
	else
	    declare -a dnsarray=(
	    "hostname"
	    "XMPP"
	    )
	fi

	if [ $ipv6_avail = "y" ]
	then
	    declare -a iparray=(
	    "v4"
	    "v6"
	    )
	else
	    declare -a iparray=(
	    "v4"
	    )
	fi

	for dnstype in "${dnsarray[@]}"
	do

	    if [ "$dnstype" = "hostname" ]
	    then
	        dnschecktype=$hostname
	    else
	        dnschecktype=$domain
	    fi

	    srvdone=n

	    for ipversion in "${iparray[@]}"
	    do

	        if [ $srvdone = n ]
	        then

	            if [ ! "$dnstype" = "SRV" ]
	            then
	                echo "${b}Now let's make sure your $dnstype IP$ipversion DNS settings are correct.${x}"
	                echo
	            else
	                echo "${b}Since you've chosen option 1, your domain is different from your hostname.${x}"
	                echo
	                echo "${b}Therefore, we have to set some DNS 'SRV' records which will direct XMPP connections for $domain to this server.${x}"
	                echo
	                echo "${b}Now let's make sure your XMPP SRV records are correct.${x}"
	                echo
	            fi

	            if [ "$dnstype" = "hostname" ]
	            then
	                declare -A digarray=(
	                [HN]=""
	                [www]="www."
	                )
	            elif [ "$dnstype" = "domain" ]
	            then
	                declare -A digarray=(
	                [HN]=""
	                [www]="www."
	                )
	            elif [ "$dnstype" = "XMPP" ]
	            then
	                declare -A digarray=(
	                [xc]="xc."
	                [xe]="xe."
	                [xi]="xi."
	                [xm]="xm."
	                [xp]="xp."
	                [xu]="xu."
	                [wu]="www.xu."
	                )
	            elif [ "$dnstype" = "SRV" ]
	            then
	                declare -A digarray=(
	                [sj]="_jabber._tcp."
	                [ss]="_xmpp-server._tcp."
	                [sc]="_xmpp-client._tcp."
	                )
	            fi

	            # [xc]="XMPP messaging groups [aka conferences / MUCs in XMPP lingo]."
	            # [xu]="XMPP HTTP uploads."
	            # [xe]="the ejabberd MOD_ECHO module."
	            # [xp]="the ejabberd MOD_PUBSUB module."
	            # [xi]="join channels on IRC servers."

	            digarrayiter=0

	            for i in "${!digarray[@]}"
	            do

	                digarrayiter=$((digarrayiter + 1))

	                if [ ! "$dnstype" = "SRV" ]
	                then
	                    echo "${b}$digarrayiter] Now checking the ${digarray[$i]}$dnschecktype DNS record in IP$ipversion...${x}"
	                    echo
	                else
	                    echo "${b}$digarrayiter] Now checking the ${digarray[$i]}$dnschecktype SRV record...${x}"
	                    echo
	                fi

	                accept=n
	                until [ $accept = "y" ]
	                do

	                    if [ ! "$dnstype" = "SRV" ]
	                    then
	                        if [ "$ipversion" = "v4" ]
	                        then
	                            thisip=$this_ipv4
	                            digresult="$(getent ahostsv4 "${digarray[$i]}""$dnschecktype". | head -1 |sed 's/ .*//')"
	                            rectype="A"
	                        else
	                            thisip=$this_ipv6
	                            digresult="$(getent ahostsv6 "${digarray[$i]}""$dnschecktype". | grep -v "$this_ipv4" | head -1 | sed 's/ .*//')"
	                            rectype="AAAA"
	                        fi
	                    else
	                        if [ ! "${digarray[$i]}" = "_xmpp-client._tcp." ]
	                        then
	                            thisip="0 0 5269 $hostname."
	                        else
	                            thisip="0 0 5222 $hostname."
	                        fi
	                        digresult="$(dig +short -t srv "${digarray[$i]}""$domain")"
	                        rectype="SRV"
	                    fi

	                    if [ -z "$digresult" ]
	                    then

	                        if [ ! "$dnstype" = "SRV" ]
	                        then
	                            echo "${r}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to be at all set.${x}"
	                            echo
	                        else
	                            echo "${r}${b}The ${digarray[$i]}$dnschecktype SRV record does NOT appear to be at all set.${x}"
	                            echo
	                        fi

	                        echo "${b}Please ensure you set your DNS record as follows:${x}"
	                        echo
	                        echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
	                        echo
	                        if [ ! "${digarray[$i]}$dnschecktype" = "$hostname" ]
	                        then
	                            if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
	                            then
	                                if [ "$ipversion" = "v4" ]
	                                then
	                                    echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
	                                    echo
	                                    echo -e "| ${digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
	                                    echo
	                                fi
	                            fi
	                        fi
	                        result=notset
	                    else
	                        if [ "$digresult" = "$thisip" ]
	                        then

	                            if [ ! "$dnstype" = "SRV" ]
	                            then
	                                echo "${g}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record appears to resolve correctly to this server.${x}"
	                                echo
	                            else
	                                echo "${g}${b}The ${digarray[$i]}$dnschecktype SRV record appears to resolve correctly to this server.${x}"
	                                echo
	                            fi

	                            echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
	                            echo
	                            result=ok
	                        else

	                            if [ ! "$dnstype" = "SRV" ]
	                            then
	                                echo "${r}${b}The ${digarray[$i]}$dnschecktype IP$ipversion DNS record does NOT appear to correctly resolve to this server.${x}"
	                                echo
	                            else
	                                echo "${r}${b}The ${digarray[$i]}$dnschecktype SRV record does NOT appear to correctly resolve to this server.${x}"
	                                echo
	                            fi

	                            echo "${b}This is the result of a DNS query for ${digarray[$i]}$dnschecktype:${x}"
	                            echo
	                            echo "$digresult"
	                            echo
	                            echo "${b}Please set it instead to:${x}"
	                            echo
	                            echo -e "| ${digarray[$i]}$dnschecktype\\t\\t$rectype\\t$thisip |"
	                            echo
	                            if [ ! "${digarray[$i]}$dnschecktype" = "$hostname" ]
	                            then
	                                if [ $rectype = "A" ] || [ $rectype = "AAAA" ]
	                                then
	                                    if [ "$ipversion" = "v4" ]
	                                    then
	                                        echo "${g}${b}You can also set this record as a CNAME [suggested choice]:${x}"
	                                        echo
	                                        echo -e "| ${digarray[$i]}$dnschecktype\\t\\tCNAME\\t$hostname |"
	                                        echo
	                                    fi
	                                fi
	                            fi
	                            result=incorrect
	                        fi
	                    fi

	                    if [ ! $result = "ok" ]
	                    then
	                        valid=n
	                        until [ $valid = "y" ]
	                        do
	                            read -n 1 -rp "${b}Test again?${x} (${b}Y${x}[es]/${b}s${x}[kip]/${b}e${x}[xit]) " answer;
	                            case $answer in
	                                "")
	                                echo
	                                valid=y
	                                accept=n
	                                ;;
	                                y)
	                                echo -e "\\n"
	                                valid=y
	                                accept=n
	                                ;;
	                                s)
	                                echo -e "\\n"
	                                echo "${b}Skipping DNS check for this record...${x}"
	                                echo
	                                valid=y
	                                accept=y
	                                ;;
	                                e)
	                                echo -e "\\n"
	                                echo "${b}Exiting...${x}"
	                                echo
	                                exit
	                                ;;
	                                *)
	                                echo -e "\\n"
	                                echo "${b}Invalid option. Retry...${x}"
	                                echo
	                                valid=n
	                                accept=n
	                                ;;
	                            esac
	                        done
	                    else
	                        accept=y
	                    fi
	                    clear

	                done

	            done

	            if [ ! "$dnstype" = "SRV" ]
	            then
	                echo "${b}Finished checking your $dnstype IP$ipversion DNS settings.${x}"
	                echo
	            else
	                echo "${b}Finished checking your XMPP SRV records.${x}"
	                echo
	                srvdone=y
	            fi

	        fi

	    done

	done
	clear

	### Set UFW rules

	echo "${b}Now setting UFW rules...${x}"
	echo

	ufw allow 5222
	ufw allow 5223
	ufw allow 5269
	ufw allow 5444
	ufw allow 80
	ufw allow 443

	echo
	echo "${b}Finished setting UFW rules.${x}"
	echo

	### Install and if necessary upgrade EasyEngine

	echo "${b}Now installing easyengine...${x}"
	echo
	wget -qO ee rt.cx/ee
	bash ee || true
	rm ee
	source /etc/bash_completion.d/ee_auto.rc
	ee update || true
	rm /tmp/eeupdate* || true
	mkdir -p /var/www/
	chown -R www-data:www-data /var/www/
	echo
	echo "${b}Finished installing easyengine.${x}"
	echo

	### Create and configure sites and TLS certificates via LetsEncrypt

	echo "${b}Now creating easyengine site for $hostname, generating its TLS certificate, and installing it...${x}"
	echo
	ee site create "$hostname" || true
	echo
	echo "${b}Finished creating easyengine site for $hostname.${x}"
	echo

	echo "${b}Now setting custom nginx config for $hostname...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/hostname.conf
	cp "$source_dir"/conf/nginx/hostname.conf /etc/nginx/sites-available/"$hostname"
	service nginx reload || true
	echo "${b}Finished setting custom nginx config for $hostname.${x}"
	echo

	echo "${b}Now updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
	echo
	ee site update "$hostname"  --le --experimental || true
	if [ ! -f /etc/letsencrypt/live/"$hostname"/fullchain.pem ]
	then
	    echo "${r}${b}There was an issue provisioning the TLS certificate for $hostname with LetsEncrypt.${x}"
	    echo
	    echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	    echo
	    echo "${b}Exiting...${x}"
	    echo
	    exit
	fi
	echo
	echo "${b}Finished updating easyengine site $hostname to TLS encrypted with LetsEncrypt...${x}"
	echo

	echo "${b}Now creating all-in-one TLS file for $hostname for ejabberd...${x}"
	echo
	touch $tls_dir/hostname.pem
	cat /etc/letsencrypt/live/"$hostname"/privkey.pem > "$tls_dir"/hostname.pem
	cat /etc/letsencrypt/live/"$hostname"/fullchain.pem >> "$tls_dir"/hostname.pem
	echo "${b}Finished creating all-in-one TLS file for $hostname for ejabberd.${x}"
	echo

	echo "${b}Now setting index.html in docroot for $hostname...${x}"
	echo
	cp "$source_dir"/conf/web/hostname/index.html /var/www/"$hostname"/htdocs/
	echo "${b}Finished setting index.html in docroot for $hostname.${x}"
	echo

	echo "${b}Now creating easyengine site for xu.$domain, generating its TLS certificate, and installing it...${x}"
	echo
	ee site create xu."$domain" || true
	echo
	echo "${b}Finished creating easyengine site for xu.$domain.${x}"
	echo

	echo "${b}Now setting custom nginx config for xu.$domain...${x}"
	echo
	sed -i "s/example.im/xu.${domain}/g" $source_dir/conf/nginx/xu.conf
	cp "$source_dir"/conf/nginx/xu.conf /etc/nginx/sites-available/xu."$domain"
	service nginx reload || true
	echo "${b}Finished setting custom nginx config for xu.$domain.${x}"
	echo

	echo "${b}Now updating easyengine site xu.$domain to TLS encrypted with LetsEncrypt...${x}"
	echo
	ee site update xu."$domain"  --le --experimental || true
	if [ ! -f /etc/letsencrypt/live/xu."$domain"/fullchain.pem ]
	then
	    echo "${r}${b}There was an issue provisioning the TLS certificate for xu.$domain with LetsEncrypt.${x}"
	    echo
	    echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	    echo
	    echo "${b}Exiting...${x}"
	    echo
	    exit
	fi
	echo
	echo "${b}Finished updating easyengine site xu.$domain to TLS encrypted with LetsEncrypt...${x}"
	echo

	echo "${b}Now creating all-in-one TLS file for xu.$domain for ejabberd...${x}"
	echo
	touch $tls_dir/xu.pem
	cat /etc/letsencrypt/live/xu."$domain"/privkey.pem > "$tls_dir"/xu.pem
	cat /etc/letsencrypt/live/xu."$domain"/fullchain.pem >> "$tls_dir"/xu.pem
	echo "${b}Finished creating all-in-one TLS file for xu.$domain for ejabberd.${x}"
	echo

	### Also provision a TLS certificate for $domain if during $config_option 1 or 2 specific configuration the user decided to point the domain here and let us automatically do the rest

	if [ $additional_tls_mode = "here" ]
	then

	    echo "${b}Since you've chosen to provision a TLS certificate for $domain on this server, now we're now going to do so.${x}"
	    echo

	    echo "${b}Now creating easyengine site for $domain, generating its TLS certificate, and installing it...${x}"
	    echo
	    ee site create "$domain" || true
	    echo
	    echo "${b}Finished creating easyengine site for $domain.${x}"
	    echo

	    echo "${b}Now setting custom nginx config for $domain...${x}"
	    echo
	    sed -i "s/example.im/${domain}/g" $source_dir/conf/nginx/domain.conf
	    cp "$source_dir"/conf/nginx/domain.conf /etc/nginx/sites-available/"$domain"
	    service nginx reload || true
	    echo "${b}Finished setting custom nginx config for $domain.${x}"
	    echo

	    echo "${b}Now updating easyengine site $domain to TLS encrypted with LetsEncrypt...${x}"
	    echo
	    ee site update "$domain"  --le --experimental || true
	    if [ ! -f /etc/letsencrypt/live/"$domain"/fullchain.pem ]
	    then
	        echo "${r}${b}There was an issue provisioning the TLS certificate for $domain with LetsEncrypt.${x}"
	        echo
	        echo "${b}Make sure you haven't skipped any DNS checks and try running the installation again...${x}"
	        echo
	        echo "${b}Exiting...${x}"
	        echo
	        exit
	    fi
	    echo
	    echo "${b}Finished updating easyengine site $domain to TLS encrypted with LetsEncrypt...${x}"
	    echo

	    echo "${b}Now creating all-in-one TLS file for $domain for ejabberd...${x}"
	    echo
	    touch $tls_dir/domain.pem
	    cat /etc/letsencrypt/live/"$domain"/privkey.pem > "$tls_dir"/domain.pem
	    cat /etc/letsencrypt/live/"$domain"/fullchain.pem >> "$tls_dir"/domain.pem
	    domain_tls_cert_location=$tls_dir/domain.pem
	    echo "${b}Finished creating all-in-one TLS file for $domain for ejabberd...${x}"
	    echo

	    echo "${b}Now setting index.html in docroot for $domain...${x}"
	    echo
	    cp "$source_dir"/conf/web/domain/index.html /var/www/"$domain"/htdocs/
	    echo "${b}Finished setting index.html in docroot for $domain.${x}"
	    echo

	    echo "${b}Now adding IPv6 support to the HTTPS version of the $domain site...${x}"
	    echo
	    sed -i "s/example.im/${domain}/g" $source_dir/conf/nginx/ssl-domain.conf
	    cp "$source_dir"/conf/nginx/ssl-domain.conf /var/www/"$domain"/conf/nginx/ssl.conf
	    echo "${b}Finished adding IPv6 support to the HTTPS version of the $domain site...${x}"
	    echo

	    echo "${b}Now adding IPv6 support to the HTTPS redirect for the $domain site...${x}"
	    echo
	    sed -i "s/example.im/${domain}/g" $source_dir/conf/nginx/force-ssl-domain.conf
	    cp "$source_dir"/conf/nginx/force-ssl-domain.conf /etc/nginx/conf.d/force-ssl-"$domain".conf
	    echo "${b}Finished adding IPv6 support to the HTTPS redirect for the $domain site...${x}"
	    echo

	fi

	### only add IPv6 to hostname site after LE TLS cert has been provisioned for all sites otherwise .well-known check will fail due to wrong webroot

	echo "${b}Now adding IPv6 support to the HTTPS version of the $hostname site...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/ssl-hostname.conf
	cp "$source_dir"/conf/nginx/ssl-hostname.conf /var/www/"$hostname"/conf/nginx/ssl.conf
	echo "${b}Finished adding IPv6 support to the HTTPS version of the $hostname site...${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
	echo
	sed -i "s/example.im/${hostname}/g" $source_dir/conf/nginx/force-ssl-hostname.conf
	cp "$source_dir"/conf/nginx/force-ssl-hostname.conf /etc/nginx/conf.d/force-ssl-"$hostname".conf
	echo "${b}Finished adding IPv6 support to the HTTPS redirect for the $hostname site...${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS version of the xu.$domain site...${x}"
	echo
	sed -i "s/example.im/xu.${domain}/g" $source_dir/conf/nginx/ssl-xu.conf
	cp "$source_dir"/conf/nginx/ssl-xu.conf /var/www/xu."$domain"/conf/nginx/ssl.conf
	echo "${b}Finished adding IPv6 support to the HTTPS version of the xu.$domain site...${x}"
	echo

	echo "${b}Now adding IPv6 support to the HTTPS redirect for the xu.$domain site...${x}"
	echo
	sed -i "s/example.im/xu.${domain}/g" $source_dir/conf/nginx/force-ssl-xu.conf
	cp "$source_dir"/conf/nginx/force-ssl-xu.conf /etc/nginx/conf.d/force-ssl-xu."$domain".conf
	echo "${b}Finished adding IPv6 support to the HTTPS redirect for the xu.$domain site...${x}"
	echo

	service nginx restart || true

	### Prepare APT for ejabberd installation

	aenigma-add_ejabberd_repo

	aenigma-install_ejabberd_config

	### Create ejabberd uploads directory

	echo "${b}Now creating uploads directory...${x}"
	echo
	mkdir -p /etc/ejabberd/uploads/
	echo "${b}Finished creating uploads directory.${x}"
	echo

	### Create HTTP uploads directory

	echo "${b}Now creating HTTP fileserver directory...${x}"
	echo
	mkdir -p /var/www/ejabberd/
	echo "${b}Finished creating HTTP fileserver directory.${x}"
	echo

	### Create logfile

	echo "${b}Now creating logfile...${x}"
	echo
	mkdir -p /var/log/ejabberd/
	touch /var/log/ejabberd/www_access.log
	echo "${b}Finished creating logfile.${x}"
	echo

	### Add backup script to crontab

	os-add_cron_job -n $short_name-backup -t "8 4 * * * " -c "bash /root/openspace42/$short_name/tools/$short_name-backup"

	### Install SSLH

	echo "${b}Now installing SSLH...${x}"
	echo
	/usr/sbin/service sslh stop &> /dev/null || true
	ssh_port="$(cat $os_base_dir/inception/ssh-port)"
	apt-get -y install libwrap0-dev libconfig8-dev || true
	rm -r "$temp_dir/sslh" &> /dev/null || true
	git clone https://github.com/yrutschle/sslh "$temp_dir/sslh"
	( cd "$temp_dir/sslh" && make install && make && cp sslh-select /usr/local/sbin/sslh )
	sed -i "s|this_ipv4-var|${this_ipv4}|g" $source_dir/conf/sslh/etc-sslh.cfg
	if [ $ipv6_avail = "y" ]
	then
	    sed -i "s|#ipv6_comma|,|g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|#ipv6_line||g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|this_ipv6-var|${this_ipv6}|g" $source_dir/conf/sslh/etc-sslh.cfg
	else
	    sed -i "s|#ipv6_comma||g" $source_dir/conf/sslh/etc-sslh.cfg
	    sed -i "s|#ipv6_line|#|g" $source_dir/conf/sslh/etc-sslh.cfg
	fi
	sed -i "s|domain-var|${domain}|g" $source_dir/conf/sslh/etc-sslh.cfg
	sed -i "s|ssh_port-var|${ssh_port}|g" $source_dir/conf/sslh/etc-sslh.cfg
	cp $source_dir/conf/sslh/etc-sslh.cfg /etc/sslh.cfg
	cp $source_dir/conf/sslh/etc-init.d.sslh /etc/init.d/sslh
	chmod +x /etc/init.d/sslh
	update-rc.d sslh defaults
	systemctl daemon-reload
	rm -r "$temp_dir/sslh"
	mkdir -p /var/run/sslh
	touch /var/run/sslh/sslh.pid
	service sslh restart || true
	echo
	echo "${b}Finished installing SSLH.${x}"
	echo

	### Ensure DPKG is available before proceeding

	os-check_dpkg_availability

	### Actually install ejabberd

	echo "${b}Now installing ejabberd...${x}"
	echo
	export DEBIAN_FRONTEND=noninteractive ; apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --force-yes ejabberd || true
	echo
	echo "${b}Finished installing ejabberd.${x}"
	echo

	### Secure permissions

	echo "${b}Now securing permissions...${x}"
	echo

	chown -R ejabberd:ejabberd $tls_dir
	chmod -R 700 $tls_dir

	chown -R ejabberd:ejabberd /etc/ejabberd/uploads/
	chmod -R 755 /etc/ejabberd/uploads/

	chown -R ejabberd:ejabberd /var/www/ejabberd/
	chmod -R 755 /var/www/ejabberd/

	echo "${b}Finished securing permissions.${x}"
	echo

	### Restart ejabberd and ensure it correctly comes up

	echo "${b}Now stopping ejabberd...${x}"
	echo
	/usr/sbin/service ejabberd stop
	sleep 8
	echo "${b}Finished stopping ejabberd.${x}"
	echo

	echo "${b}Now starting ejabberd...${x}"
	/usr/sbin/service ejabberd start
	echo
	sleep 8
	/usr/sbin/ejabberdctl status
	echo
	echo "${b}Finished starting ejabberd.${x}"
	echo

	### Register ejabberd admin user

	echo "${b}Now registering ejabberd admin user [if it doesn't yet exist]...${x}"
	echo
	ejab_admin_pw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
	/usr/sbin/ejabberdctl register admin "$domain" "$ejab_admin_pw" &> /dev/null || true
	echo "${b}Finished registering ejabberd admin user.${x}"
	echo
	clear

	if [ -f $conf_dir/ejab_admin_pw_set ]
	then
	    read -rp "${b}Leave ejabberd admin user password the same as previously set? (Y/n): ${x}" -n 1
	    echo
	    if [[ ! $REPLY =~ ^[Nn]$ ]]
	    then
	        echo "${b}Skipping ejabberd admin user password reset.${x}"
	        echo
	        ejab_admin_pwreset=n
	    else
	        echo
	        echo "${b}Ok, resetting ejabberd admin user password to: | $ejab_admin_pw | ${x}"
	        echo
	        /usr/sbin/ejabberdctl change_password admin "$domain" "$ejab_admin_pw"
	        ejab_admin_pwreset=y
	    fi
	else
	    touch $conf_dir/ejab_admin_pw_set
	    ejab_admin_pwreset=y
	fi

	### Update ejabberd's module repo

	echo "${b}Now updating ejabberd's module repo...${x}"
	echo
	set +e
	/usr/sbin/ejabberdctl modules_update_specs
	set -e
	echo "${b}Finished updating ejabberd's module repo...${x}"
	echo

	### Create shared roster groups

	echo "${b}Now creating 'ADMIN:EVERYBODY' and 'ADMIN:ONLINE' shared roster groups [admin@$domain can see 'everybody' and 'all online']...${x}"
	echo
	/usr/sbin/ejabberdctl srg_create everybody "$domain" "everybody [$domain]" "This aenigma group includes every user on this domain" ""
	/usr/sbin/ejabberdctl srg-user-add @all@ localhost everybody "$domain"
	/usr/sbin/ejabberdctl srg_create online "$domain" "online [$domain]" "This aenigma group includes every user who is online on this domain" ""
	/usr/sbin/ejabberdctl srg-user-add @online@ localhost online "$domain"
	/usr/sbin/ejabberdctl srg_create admin "$domain" admin "This is a shared roster group set by aenigma" "everybody\\nonline"
	/usr/sbin/ejabberdctl srg-user-add admin "$domain" admin "$domain"
	echo "${b}Finished creating shared roster groups.${x}"
	echo
	clear

	### Run a generic APT operation to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final run of APT to ensure all package installations have completed successfully...${x}"
	echo
	set +e
	if apt-get -y upgrade
	then
	    echo
	    echo "${g}${b}All APT package installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during APT operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Run an nginx restart to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x}"
	echo
	set +e
	if service nginx restart
	then
	    echo
	    echo "${g}${b}All nginx installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during nginx operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Run an sslh restart to catch its output and alert the user if something has gone wrong

	echo "${b}Now performing a final restart of nginx to ensure all related installations have completed successfully...${x}"
	echo
	set +e
	if service sslh restart
	then
	    echo
	    echo "${g}${b}All sslh installations completed successfully...${x}"
	    echo
	else
	    echo
	    echo "${r}${b}An error has occured during sslh operations.${x}"
	    echo
	    echo "${b}This was the last step in this installation, so it's possible your end result is at least partially working.${x}"
	    echo
	    echo "${b}Please review the above log and try running the installation again. If necessary open an issue on github. Thank you.${x}"
	    echo
	    read -rp "${b}[press enter to continue reading...]${x}"
	fi
	set -e
	clear

	### Pring login information and credentials

	echo "${g}${b}You can finally log in:${x}"
	echo
	echo "${b}https://$hostname${x}"
	echo
	echo "${b}admin@$domain${x}"
	echo

	if [ $ejab_admin_pwreset = "y" ]
	then
	    echo "${b}$ejab_admin_pw${x}"
	    echo
	else
	    echo "${b}[your previously set password]${x}"
	    echo
	fi

	read -rp "${b}[press enter to continue reading...]${x}"
	clear

	### Generate aenigma-specific DHparam file

	os-generate_project_specific_dhparam

	############################################################################
	############################################################################
	############################################################################

}

################################################################################
